ğŸ“¦ CAJA 04: MOTOR CORE (LÃ“GICA PURA)
Desglose AtÃ³mico Completo

Copyâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                      â•‘
â•‘                    ğŸ“¦ CAJA 04: MOTOR CORE (LÃ“GICA PURA)                              â•‘
â•‘                                                                                      â•‘
â•‘    "El corazÃ³n matemÃ¡tico del sistema - Funciones puras sin efectos secundarios"    â•‘
â•‘                                                                                      â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                            â”‚   â•‘
â•‘    â”‚   âš™ï¸ 04.1 Vectores      âš™ï¸ 04.2 Niveles       âš™ï¸ 04.3 Salud              â”‚   â•‘
â•‘    â”‚   Sistema de Vectores   CÃ¡lculo de Niveles    Sistema de Corazones        â”‚   â•‘
â•‘    â”‚                                                                            â”‚   â•‘
â•‘    â”‚   âš™ï¸ 04.4 Racha         âš™ï¸ 04.5 Judgement     âš™ï¸ 04.6 Muerte              â”‚   â•‘
â•‘    â”‚   Streak & Multipliers  Cierre de DÃ­a         Reset & ResurrecciÃ³n        â”‚   â•‘
â•‘    â”‚                                                                            â”‚   â•‘
â•‘    â”‚   âš™ï¸ 04.7 EconomÃ­a      âš™ï¸ 04.8 Protocolo     âš™ï¸ 04.9 Validaciones        â”‚   â•‘
â•‘    â”‚   BTC Rewards           100 DÃ­as Structure    Business Rules              â”‚   â•‘
â•‘    â”‚                                                                            â”‚   â•‘
â•‘    â”‚   âš™ï¸ 04.10 Estados                                                        â”‚   â•‘
â•‘    â”‚   State Machines                                                          â”‚   â•‘
â•‘    â”‚                                                                            â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                                                                                      â•‘
â•‘    Responsable: Claude (DiseÃ±o) + Antigravity (ImplementaciÃ³n)                      â•‘
â•‘    Entregables: Archivos TypeScript en /src/lib/core                                â•‘
â•‘    Tiempo Estimado: 8-12 horas de desarrollo                                        â•‘
â•‘                                                                                      â•‘
â•‘    PRINCIPIO FUNDAMENTAL:                                                           â•‘
â•‘    Toda la lÃ³gica en esta caja es PURA - sin I/O, sin DB, sin API calls.           â•‘
â•‘    Input â†’ CÃ¡lculo â†’ Output. 100% testeable.                                        â•‘
â•‘                                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ÃNDICE DE DESGLOSE ATÃ“MICO - CAJA 04

SUBCAJA 04.1: Sistema de Vectores
SUBCAJA 04.2: Sistema de Niveles
SUBCAJA 04.3: Sistema de Salud
SUBCAJA 04.4: Sistema de Racha
SUBCAJA 04.5: Judgement Night
SUBCAJA 04.6: Muerte y ResurrecciÃ³n
SUBCAJA 04.7: EconomÃ­a
SUBCAJA 04.8: Protocolo de 100 DÃ­as
SUBCAJA 04.9: Validaciones de Negocio
SUBCAJA 04.10: MÃ¡quinas de Estado


SUBCAJA 04.1: SISTEMA DE VECTORES
El CorazÃ³n del Espejo Bio-Digital
Archivos a Crear
CopyRuta: /src/lib/core/vectors/
â”œâ”€â”€ index.ts              (Exports pÃºblicos)
â”œâ”€â”€ types.ts              (Tipos de vectores)
â”œâ”€â”€ constants.ts          (Constantes y modificadores)
â”œâ”€â”€ calculations.ts       (Funciones de cÃ¡lculo)
â”œâ”€â”€ task-impact.ts        (Impacto de tareas en vectores)
â”œâ”€â”€ decay.ts              (Decaimiento biolÃ³gico)
â””â”€â”€ vectors.test.ts       (Tests unitarios)

TamaÃ±o Estimado: ~800 lÃ­neas total
Tiempo de GeneraciÃ³n: 60-90 minutos
Estructura del MÃ³dulo
Copy/src/lib/core/vectors/
â”‚
â”œâ”€â”€ ğŸ“„ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ VectorName (enum)
â”‚   â”‚   â”œâ”€â”€ AURA = 'aura_lvl'
â”‚   â”‚   â”œâ”€â”€ JAWLINE = 'face_lvl'
â”‚   â”‚   â”œâ”€â”€ WEALTH = 'wealth_lvl'
â”‚   â”‚   â”œâ”€â”€ MUSCLE = 'muscle_lvl'
â”‚   â”‚   â”œâ”€â”€ FAT = 'fat_lvl'
â”‚   â”‚   â””â”€â”€ ENV = 'env_lvl'
â”‚   â”‚
â”‚   â”œâ”€â”€ VectorState (interface)
â”‚   â”‚   â”œâ”€â”€ aura_lvl: number      // 1.00 - 13.00
â”‚   â”‚   â”œâ”€â”€ face_lvl: number      // 1.00 - 13.00
â”‚   â”‚   â”œâ”€â”€ wealth_lvl: number    // 1.00 - 13.00
â”‚   â”‚   â”œâ”€â”€ muscle_lvl: number    // 1.00 - 13.00
â”‚   â”‚   â”œâ”€â”€ fat_lvl: number       // 13.00 - 1.00 (INVERSO)
â”‚   â”‚   â””â”€â”€ env_lvl: number       // 1 - 13 (entero)
â”‚   â”‚
â”‚   â”œâ”€â”€ TaskArchetype (enum)
â”‚   â”‚   â”œâ”€â”€ MENTAL = 'mental'           // Afecta AURA
â”‚   â”‚   â”œâ”€â”€ CARA = 'cara'               // Afecta JAWLINE
â”‚   â”‚   â”œâ”€â”€ PRODUCTIVIDAD = 'productividad'  // Afecta WEALTH
â”‚   â”‚   â””â”€â”€ FISICO = 'fisico'           // Afecta MUSCLE & FAT
â”‚   â”‚
â”‚   â”œâ”€â”€ TaskCategory (enum)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ // ARQUETIPO MENTAL
â”‚   â”‚   â”œâ”€â”€ MEDITATION = 'meditation'
â”‚   â”‚   â”œâ”€â”€ COLD_SHOWER = 'cold_shower'
â”‚   â”‚   â”œâ”€â”€ READING = 'reading'
â”‚   â”‚   â”œâ”€â”€ WAKE_EARLY = 'wake_early'
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ // ARQUETIPO CARA
â”‚   â”‚   â”œâ”€â”€ POSTURE = 'posture'
â”‚   â”‚   â”œâ”€â”€ FACIAL = 'facial'
â”‚   â”‚   â”œâ”€â”€ KEGEL = 'kegel'
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ // ARQUETIPO PRODUCTIVIDAD
â”‚   â”‚   â”œâ”€â”€ JOURNAL = 'journal'
â”‚   â”‚   â”œâ”€â”€ SKILL_LEARNING = 'skill_learning'
â”‚   â”‚   â”œâ”€â”€ FOCUS_WORK = 'focus_work'
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ // ARQUETIPO FÃSICO
â”‚   â”‚   â”œâ”€â”€ STRENGTH = 'strength'
â”‚   â”‚   â”œâ”€â”€ CARDIO = 'cardio'
â”‚   â”‚   â””â”€â”€ HYDRATION = 'hydration'
â”‚   â”‚
â”‚   â”œâ”€â”€ VectorModifier (interface)
â”‚   â”‚   â”œâ”€â”€ vector: VectorName
â”‚   â”‚   â”œâ”€â”€ delta: number         // Cambio a aplicar
â”‚   â”‚   â””â”€â”€ operation: 'add' | 'subtract'
â”‚   â”‚
â”‚   â””â”€â”€ TaskImpact (interface)
â”‚       â”œâ”€â”€ category: TaskCategory
â”‚       â”œâ”€â”€ archetype: TaskArchetype
â”‚       â”œâ”€â”€ modifiers: VectorModifier[]
â”‚       â””â”€â”€ btcReward: number
â”‚
â”œâ”€â”€ ğŸ“„ constants.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ VECTOR_LIMITS
â”‚   â”‚   â”œâ”€â”€ AURA: { min: 1.00, max: 13.00 }
â”‚   â”‚   â”œâ”€â”€ JAWLINE: { min: 1.00, max: 13.00 }
â”‚   â”‚   â”œâ”€â”€ WEALTH: { min: 1.00, max: 13.00 }
â”‚   â”‚   â”œâ”€â”€ MUSCLE: { min: 1.00, max: 13.00 }
â”‚   â”‚   â”œâ”€â”€ FAT: { min: 1.00, max: 13.00 }  // Nota: 13 es el peor estado
â”‚   â”‚   â””â”€â”€ ENV: { min: 1, max: 13 }
â”‚   â”‚
â”‚   â”œâ”€â”€ TASK_CATEGORY_TO_ARCHETYPE
â”‚   â”‚   â”œâ”€â”€ meditation â†’ MENTAL
â”‚   â”‚   â”œâ”€â”€ cold_shower â†’ MENTAL
â”‚   â”‚   â”œâ”€â”€ reading â†’ MENTAL
â”‚   â”‚   â”œâ”€â”€ wake_early â†’ MENTAL
â”‚   â”‚   â”œâ”€â”€ posture â†’ CARA
â”‚   â”‚   â”œâ”€â”€ facial â†’ CARA
â”‚   â”‚   â”œâ”€â”€ kegel â†’ CARA
â”‚   â”‚   â”œâ”€â”€ journal â†’ PRODUCTIVIDAD
â”‚   â”‚   â”œâ”€â”€ skill_learning â†’ PRODUCTIVIDAD
â”‚   â”‚   â”œâ”€â”€ focus_work â†’ PRODUCTIVIDAD
â”‚   â”‚   â”œâ”€â”€ strength â†’ FISICO
â”‚   â”‚   â”œâ”€â”€ cardio â†’ FISICO
â”‚   â”‚   â””â”€â”€ hydration â†’ FISICO
â”‚   â”‚
â”‚   â”œâ”€â”€ TASK_MODIFIERS (Impacto de cada tarea)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ MEDITATION
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: AURA, delta: 0.05, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 15
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ COLD_SHOWER
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: AURA, delta: 0.03, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 20
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ READING
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: AURA, delta: 0.03, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 15
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ WAKE_EARLY
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: AURA, delta: 0.02, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 10
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ POSTURE
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: JAWLINE, delta: 0.03, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 15
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ FACIAL
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: JAWLINE, delta: 0.04, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 15
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ KEGEL
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: JAWLINE, delta: 0.02, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 10
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ JOURNAL
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: WEALTH, delta: 0.03, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 20
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ SKILL_LEARNING (por hora)
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: WEALTH, delta: 0.05, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 25
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ FOCUS_WORK (por hora)
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: WEALTH, delta: 0.02, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 20
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ STRENGTH
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: MUSCLE, delta: 0.05, operation: 'add' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 30
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ CARDIO
â”‚   â”‚   â”‚   â”œâ”€â”€ { vector: FAT, delta: 0.05, operation: 'subtract' }
â”‚   â”‚   â”‚   â””â”€â”€ btcReward: 25
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ HYDRATION
â”‚   â”‚       â”œâ”€â”€ { vector: FAT, delta: 0.01, operation: 'subtract' }
â”‚   â”‚       â”œâ”€â”€ { vector: MUSCLE, delta: 0.01, operation: 'add' }
â”‚   â”‚       â””â”€â”€ btcReward: 10
â”‚   â”‚
â”‚   â”œâ”€â”€ DAILY_DECAY (Decaimiento si no se hace la tarea)
â”‚   â”‚   â”œâ”€â”€ AURA: -0.01 por dÃ­a sin tarea mental
â”‚   â”‚   â”œâ”€â”€ JAWLINE: -0.01 por dÃ­a sin tarea cara
â”‚   â”‚   â”œâ”€â”€ WEALTH: -0.01 por dÃ­a sin productividad
â”‚   â”‚   â”œâ”€â”€ MUSCLE: -0.02 por dÃ­a sin fuerza
â”‚   â”‚   â””â”€â”€ FAT: +0.02 por dÃ­a sin cardio (aumenta)
â”‚   â”‚
â”‚   â””â”€â”€ INITIAL_VECTOR_STATE
â”‚       â”œâ”€â”€ aura_lvl: 1.00
â”‚       â”œâ”€â”€ face_lvl: 1.00
â”‚       â”œâ”€â”€ wealth_lvl: 1.00
â”‚       â”œâ”€â”€ muscle_lvl: 1.00
â”‚       â”œâ”€â”€ fat_lvl: 13.00  // Empieza en el peor estado
â”‚       â””â”€â”€ env_lvl: 1
â”‚
â”œâ”€â”€ ğŸ“„ calculations.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ clamp(value, min, max): number
â”‚   â”‚   â””â”€â”€ Limita un valor entre min y max
â”‚   â”‚
â”‚   â”œâ”€â”€ roundToDecimals(value, decimals): number
â”‚   â”‚   â””â”€â”€ Redondea a N decimales (usamos 2)
â”‚   â”‚
â”‚   â”œâ”€â”€ applyModifier(currentValue, modifier): number
â”‚   â”‚   â”œâ”€â”€ Input: valor actual, VectorModifier
â”‚   â”‚   â”œâ”€â”€ Process: aplica delta con operaciÃ³n
â”‚   â”‚   â”œâ”€â”€ Output: nuevo valor (clamped)
â”‚   â”‚   â””â”€â”€ Respeta VECTOR_LIMITS
â”‚   â”‚
â”‚   â”œâ”€â”€ calculatePhysiqueScore(muscle_lvl, fat_lvl): number
â”‚   â”‚   â”œâ”€â”€ FÃ³rmula: (muscle_lvl + (14 - fat_lvl)) / 2
â”‚   â”‚   â””â”€â”€ Output: 1.0 - 13.0 (score combinado)
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateOverallScore(vectors: VectorState): number
â”‚   â”‚   â”œâ”€â”€ Promedio ponderado de todos los vectores
â”‚   â”‚   â”œâ”€â”€ AURA: 20%
â”‚   â”‚   â”œâ”€â”€ JAWLINE: 15%
â”‚   â”‚   â”œâ”€â”€ WEALTH: 25%
â”‚   â”‚   â”œâ”€â”€ PHYSIQUE (combinado): 30%
â”‚   â”‚   â”œâ”€â”€ ENV: 10%
â”‚   â”‚   â””â”€â”€ Output: 1.0 - 13.0
â”‚   â”‚
â”‚   â””â”€â”€ getVectorDelta(before: VectorState, after: VectorState): VectorDelta
â”‚       â””â”€â”€ Retorna las diferencias entre dos estados
â”‚
â”œâ”€â”€ ğŸ“„ task-impact.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ getTaskImpact(category: TaskCategory): TaskImpact
â”‚   â”‚   â””â”€â”€ Retorna los modificadores para una categorÃ­a de tarea
â”‚   â”‚
â”‚   â”œâ”€â”€ applyTaskToVectors(
â”‚   â”‚     vectors: VectorState, 
â”‚   â”‚     category: TaskCategory
â”‚   â”‚   ): VectorState
â”‚   â”‚   â”œâ”€â”€ Input: estado actual, categorÃ­a de tarea
â”‚   â”‚   â”œâ”€â”€ Process: aplica todos los modificadores de la tarea
â”‚   â”‚   â””â”€â”€ Output: nuevo estado de vectores
â”‚   â”‚
â”‚   â”œâ”€â”€ applyMultipleTasksToVectors(
â”‚   â”‚     vectors: VectorState, 
â”‚   â”‚     tasks: TaskCategory[]
â”‚   â”‚   ): VectorState
â”‚   â”‚   â””â”€â”€ Aplica mÃºltiples tareas secuencialmente
â”‚   â”‚
â”‚   â””â”€â”€ calculateTotalBtcFromTasks(tasks: TaskCategory[]): number
â”‚       â””â”€â”€ Suma las recompensas BTC de las tareas completadas
â”‚
â”œâ”€â”€ ğŸ“„ decay.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ getDecayForArchetype(archetype: TaskArchetype): VectorModifier[]
â”‚   â”‚   â””â”€â”€ Retorna el decay a aplicar si no se hizo ninguna tarea del arquetipo
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateDailyDecay(
â”‚   â”‚     completedTasks: TaskCategory[],
â”‚   â”‚     allRequiredTasks: TaskCategory[]
â”‚   â”‚   ): VectorModifier[]
â”‚   â”‚   â”œâ”€â”€ Determina quÃ© arquetipos no tuvieron tareas
â”‚   â”‚   â””â”€â”€ Retorna los decays a aplicar
â”‚   â”‚
â”‚   â””â”€â”€ applyDecayToVectors(
â”‚       vectors: VectorState, 
â”‚       decays: VectorModifier[]
â”‚     ): VectorState
â”‚       â””â”€â”€ Aplica el decay al estado
â”‚
â””â”€â”€ ğŸ“„ vectors.test.ts
    â”‚
    â”œâ”€â”€ describe('clamp')
    â”‚   â”œâ”€â”€ it('returns value when within range')
    â”‚   â”œâ”€â”€ it('returns min when value below min')
    â”‚   â””â”€â”€ it('returns max when value above max')
    â”‚
    â”œâ”€â”€ describe('applyModifier')
    â”‚   â”œâ”€â”€ it('adds delta correctly')
    â”‚   â”œâ”€â”€ it('subtracts delta correctly')
    â”‚   â”œâ”€â”€ it('respects max limit')
    â”‚   â”œâ”€â”€ it('respects min limit')
    â”‚   â””â”€â”€ it('handles FAT vector inversion correctly')
    â”‚
    â”œâ”€â”€ describe('applyTaskToVectors')
    â”‚   â”œâ”€â”€ it('increases AURA for meditation')
    â”‚   â”œâ”€â”€ it('increases JAWLINE for facial')
    â”‚   â”œâ”€â”€ it('increases WEALTH for journal')
    â”‚   â”œâ”€â”€ it('increases MUSCLE for strength')
    â”‚   â”œâ”€â”€ it('decreases FAT for cardio')
    â”‚   â””â”€â”€ it('applies multiple modifiers for hydration')
    â”‚
    â”œâ”€â”€ describe('calculatePhysiqueScore')
    â”‚   â”œâ”€â”€ it('returns 1 for worst state (muscle=1, fat=13)')
    â”‚   â”œâ”€â”€ it('returns 13 for best state (muscle=13, fat=1)')
    â”‚   â””â”€â”€ it('returns 7 for middle state')
    â”‚
    â”œâ”€â”€ describe('calculateDailyDecay')
    â”‚   â”œâ”€â”€ it('returns no decay when all archetypes have tasks')
    â”‚   â”œâ”€â”€ it('returns AURA decay when no mental tasks')
    â”‚   â”œâ”€â”€ it('returns FAT increase when no cardio')
    â”‚   â””â”€â”€ it('returns multiple decays for multiple missing archetypes')
    â”‚
    â””â”€â”€ describe('applyDecayToVectors')
        â”œâ”€â”€ it('applies single decay correctly')
        â”œâ”€â”€ it('applies multiple decays correctly')
        â””â”€â”€ it('respects limits after decay')
Tareas AtÃ³micas para 04.1 Sistema de Vectores
yamlCopyTAREA-04.1.1:
  Nombre: "Crear estructura de carpetas para vectors"
  AcciÃ³n: "Crear /src/lib/core/vectors/ con archivos vacÃ­os"
  Responsable: Antigravity
  Comando: |
    mkdir -p src/lib/core/vectors
    touch src/lib/core/vectors/{index,types,constants,calculations,task-impact,decay}.ts
    touch src/lib/core/vectors/vectors.test.ts
  Criterio de Ã‰xito: "Carpeta y archivos existen"

TAREA-04.1.2:
  Nombre: "Implementar types.ts"
  AcciÃ³n: "Definir todos los tipos e interfaces"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea el archivo /src/lib/core/vectors/types.ts con:
    
    1. enum VectorName con los 6 vectores del cuestionario1:
       - AURA, JAWLINE, WEALTH, MUSCLE, FAT, ENV
    
    2. interface VectorState con los campos exactos de la DB:
       - aura_lvl, face_lvl, wealth_lvl, muscle_lvl, fat_lvl, env_lvl
    
    3. enum TaskArchetype: MENTAL, CARA, PRODUCTIVIDAD, FISICO
    
    4. enum TaskCategory con TODAS las categorÃ­as del cuestionario1:
       - Mental: meditation, cold_shower, reading, wake_early
       - Cara: posture, facial, kegel
       - Productividad: journal, skill_learning, focus_work
       - FÃ­sico: strength, cardio, hydration
    
    5. interface VectorModifier, TaskImpact, VectorDelta
    
    Usa TypeScript estricto, documenta con JSDoc.
  Criterio de Ã‰xito: "Tipos compilan sin errores"

TAREA-04.1.3:
  Nombre: "Implementar constants.ts"
  AcciÃ³n: "Definir todas las constantes"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/vectors/constants.ts con:
    
    1. VECTOR_LIMITS: objeto con min/max para cada vector
       - Todos van 1.00-13.00 excepto ENV que es 1-13 entero
       - FAT es especial: 13 es malo, 1 es bueno
    
    2. TASK_CATEGORY_TO_ARCHETYPE: mapeo de categorÃ­a a arquetipo
    
    3. TASK_MODIFIERS: objeto con el impacto de cada tarea
       Basado en cuestionario1:
       - meditation: AURA +0.05, 15 BTC
       - cold_shower: AURA +0.03, 20 BTC
       - reading: AURA +0.03, 15 BTC
       - wake_early: AURA +0.02, 10 BTC
       - posture: JAWLINE +0.03, 15 BTC
       - facial: JAWLINE +0.04, 15 BTC
       - kegel: JAWLINE +0.02, 10 BTC
       - journal: WEALTH +0.03, 20 BTC
       - skill_learning: WEALTH +0.05/hora, 25 BTC
       - focus_work: WEALTH +0.02/hora, 20 BTC
       - strength: MUSCLE +0.05, 30 BTC
       - cardio: FAT -0.05, 25 BTC
       - hydration: FAT -0.01, MUSCLE +0.01, 10 BTC
    
    4. DAILY_DECAY: decay por no hacer tareas
       - AURA: -0.01 sin mental
       - JAWLINE: -0.01 sin cara
       - WEALTH: -0.01 sin productividad
       - MUSCLE: -0.02 sin fuerza
       - FAT: +0.02 sin cardio
    
    5. INITIAL_VECTOR_STATE: estado inicial dÃ­a 1
    
    Usa `as const` para type safety.
  Criterio de Ã‰xito: "Constantes exportan correctamente"

TAREA-04.1.4:
  Nombre: "Implementar calculations.ts - Funciones bÃ¡sicas"
  AcciÃ³n: "Implementar clamp, roundToDecimals, applyModifier"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/vectors/calculations.ts con:
    
    1. function clamp(value: number, min: number, max: number): number
       - Retorna value si estÃ¡ en rango
       - Retorna min si value < min
       - Retorna max si value > max
    
    2. function roundToDecimals(value: number, decimals: number): number
       - Usa Math.round(value * 10^decimals) / 10^decimals
    
    3. function applyModifier(
         currentValue: number,
         modifier: VectorModifier
       ): number
       - Si operation === 'add': currentValue + delta
       - Si operation === 'subtract': currentValue - delta
       - Clamp resultado usando VECTOR_LIMITS del vector correspondiente
       - Redondear a 2 decimales
    
    IMPORTANTE: Para FAT, recuerda que menor es mejor (1 = definido, 13 = obeso)
  Criterio de Ã‰xito: "Funciones pasan tests bÃ¡sicos"

TAREA-04.1.5:
  Nombre: "Implementar calculations.ts - Funciones de score"
  AcciÃ³n: "Implementar calculatePhysiqueScore, calculateOverallScore"
  Responsable: Antigravity
  Prompt para Antigravity: |
    ContinÃºa en /src/lib/core/vectors/calculations.ts:
    
    4. function calculatePhysiqueScore(
         muscle_lvl: number, 
         fat_lvl: number
       ): number
       - FÃ³rmula: (muscle_lvl + (14 - fat_lvl)) / 2
       - Esto hace que fat_lvl se "invierta" para el cÃ¡lculo
       - Resultado: 1.0 a 13.0
       - Redondear a 2 decimales
    
    5. function calculateOverallScore(vectors: VectorState): number
       - Pesos (del cuestionario1):
         - AURA: 20%
         - JAWLINE: 15%
         - WEALTH: 25%
         - PHYSIQUE (usar calculatePhysiqueScore): 30%
         - ENV: 10%
       - FÃ³rmula: suma ponderada de todos
       - Resultado: 1.0 a 13.0
    
    6. function getVectorDelta(
         before: VectorState, 
         after: VectorState
       ): Record<VectorName, number>
       - Calcula la diferencia entre dos estados
       - Ãštil para mostrar "+0.05 AURA" en la UI
  Criterio de Ã‰xito: "CÃ¡lculos matemÃ¡ticos correctos"

TAREA-04.1.6:
  Nombre: "Implementar task-impact.ts"
  AcciÃ³n: "Funciones para aplicar tareas a vectores"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/vectors/task-impact.ts:
    
    1. function getTaskImpact(category: TaskCategory): TaskImpact
       - Busca en TASK_MODIFIERS
       - Retorna el impacto completo (modifiers + btcReward)
    
    2. function applyTaskToVectors(
         vectors: VectorState,
         category: TaskCategory
       ): VectorState
       - Obtiene el impacto de la tarea
       - Aplica cada modifier al vector correspondiente
       - Retorna NUEVO objeto (inmutable)
       - NO muta el original
    
    3. function applyMultipleTasksToVectors(
         vectors: VectorState,
         tasks: TaskCategory[]
       ): VectorState
       - Usa reduce para aplicar secuencialmente
       - Orden importa para los lÃ­mites
    
    4. function calculateTotalBtcFromTasks(
         tasks: TaskCategory[]
       ): number
       - Suma todos los btcReward
       - No considera multiplicadores (eso es de streak)
    
    IMPORTANTE: Todas las funciones deben ser PURAS (sin side effects)
  Criterio de Ã‰xito: "Tareas modifican vectores correctamente"

TAREA-04.1.7:
  Nombre: "Implementar decay.ts"
  AcciÃ³n: "Funciones de decaimiento biolÃ³gico"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/vectors/decay.ts:
    
    1. function getArchetypesFromTasks(
         tasks: TaskCategory[]
       ): Set<TaskArchetype>
       - Mapea cada tarea a su arquetipo
       - Retorna set de arquetipos representados
    
    2. function getMissingArchetypes(
         completedTasks: TaskCategory[]
       ): TaskArchetype[]
       - Compara con los 4 arquetipos
       - Retorna los que faltan
    
    3. function getDecayForArchetype(
         archetype: TaskArchetype
       ): VectorModifier[]
       - MENTAL â†’ AURA -0.01
       - CARA â†’ JAWLINE -0.01
       - PRODUCTIVIDAD â†’ WEALTH -0.01
       - FISICO â†’ MUSCLE -0.02, FAT +0.02
    
    4. function calculateDailyDecay(
         completedTasks: TaskCategory[]
       ): VectorModifier[]
       - Obtiene arquetipos faltantes
       - Acumula todos los decays necesarios
    
    5. function applyDecayToVectors(
         vectors: VectorState,
         decays: VectorModifier[]
       ): VectorState
       - Aplica cada decay usando applyModifier
       - Retorna nuevo estado
    
    NOTA: El decay se aplica en Judgement Night si no hubo
    ninguna tarea del arquetipo ese dÃ­a.
  Criterio de Ã‰xito: "Decay se calcula y aplica correctamente"

TAREA-04.1.8:
  Nombre: "Implementar index.ts"
  AcciÃ³n: "Exports pÃºblicos del mÃ³dulo"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/vectors/index.ts exportando todo lo pÃºblico:
    
    // Types
    export type { VectorState, VectorModifier, TaskImpact, VectorDelta } from './types';
    export { VectorName, TaskArchetype, TaskCategory } from './types';
    
    // Constants
    export { 
      VECTOR_LIMITS, 
      TASK_MODIFIERS, 
      DAILY_DECAY,
      INITIAL_VECTOR_STATE 
    } from './constants';
    
    // Calculations
    export {
      clamp,
      roundToDecimals,
      applyModifier,
      calculatePhysiqueScore,
      calculateOverallScore,
      getVectorDelta
    } from './calculations';
    
    // Task Impact
    export {
      getTaskImpact,
      applyTaskToVectors,
      applyMultipleTasksToVectors,
      calculateTotalBtcFromTasks
    } from './task-impact';
    
    // Decay
    export {
      calculateDailyDecay,
      applyDecayToVectors
    } from './decay';
  Criterio de Ã‰xito: "Imports funcionan desde fuera del mÃ³dulo"

TAREA-04.1.9:
  Nombre: "Implementar tests - clamp y applyModifier"
  AcciÃ³n: "Tests unitarios de funciones bÃ¡sicas"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/vectors/vectors.test.ts:
    
    import { describe, it, expect } from 'vitest';
    import { clamp, applyModifier, ... } from './index';
    
    describe('clamp', () => {
      it('returns value when within range', () => {
        expect(clamp(5, 1, 10)).toBe(5);
      });
      
      it('returns min when value below min', () => {
        expect(clamp(-5, 1, 10)).toBe(1);
      });
      
      it('returns max when value above max', () => {
        expect(clamp(15, 1, 10)).toBe(10);
      });
      
      it('handles edge case at min', () => {
        expect(clamp(1, 1, 10)).toBe(1);
      });
      
      it('handles edge case at max', () => {
        expect(clamp(10, 1, 10)).toBe(10);
      });
    });
    
    describe('applyModifier', () => {
      it('adds delta correctly', () => {
        const result = applyModifier(5.00, {
          vector: VectorName.AURA,
          delta: 0.05,
          operation: 'add'
        });
        expect(result).toBe(5.05);
      });
      
      it('subtracts delta correctly', () => {...});
      it('respects max limit (13)', () => {...});
      it('respects min limit (1)', () => {...});
    });
  Criterio de Ã‰xito: "Tests pasan"

TAREA-04.1.10:
  Nombre: "Implementar tests - task impact"
  AcciÃ³n: "Tests de aplicaciÃ³n de tareas"
  Responsable: Antigravity
  Prompt para Antigravity: |
    ContinÃºa en vectors.test.ts:
    
    describe('applyTaskToVectors', () => {
      const initialState: VectorState = {
        aura_lvl: 1.00,
        face_lvl: 1.00,
        wealth_lvl: 1.00,
        muscle_lvl: 1.00,
        fat_lvl: 13.00,
        env_lvl: 1
      };
      
      it('increases AURA for meditation task', () => {
        const result = applyTaskToVectors(initialState, TaskCategory.MEDITATION);
        expect(result.aura_lvl).toBe(1.05);
        expect(result.face_lvl).toBe(1.00); // Sin cambio
      });
      
      it('increases JAWLINE for facial task', () => {
        const result = applyTaskToVectors(initialState, TaskCategory.FACIAL);
        expect(result.face_lvl).toBe(1.04);
      });
      
      it('decreases FAT for cardio task', () => {
        const result = applyTaskToVectors(initialState, TaskCategory.CARDIO);
        expect(result.fat_lvl).toBe(12.95); // 13 - 0.05
      });
      
      it('does not mutate original state', () => {
        const original = { ...initialState };
        applyTaskToVectors(initialState, TaskCategory.MEDITATION);
        expect(initialState).toEqual(original);
      });
      
      it('applies multiple modifiers for hydration', () => {
        const result = applyTaskToVectors(initialState, TaskCategory.HYDRATION);
        expect(result.fat_lvl).toBe(12.99); // -0.01
        expect(result.muscle_lvl).toBe(1.01); // +0.01
      });
    });
  Criterio de Ã‰xito: "Tests pasan"

TAREA-04.1.11:
  Nombre: "Implementar tests - decay"
  AcciÃ³n: "Tests de decaimiento biolÃ³gico"
  Responsable: Antigravity
  Prompt para Antigravity: |
    ContinÃºa en vectors.test.ts:
    
    describe('calculateDailyDecay', () => {
      it('returns empty array when all archetypes have tasks', () => {
        const tasks = [
          TaskCategory.MEDITATION, // Mental
          TaskCategory.FACIAL,     // Cara
          TaskCategory.JOURNAL,    // Productividad
          TaskCategory.STRENGTH    // FÃ­sico
        ];
        const decay = calculateDailyDecay(tasks);
        expect(decay).toHaveLength(0);
      });
      
      it('returns AURA decay when no mental tasks', () => {
        const tasks = [
          TaskCategory.FACIAL,
          TaskCategory.JOURNAL,
          TaskCategory.STRENGTH
        ];
        const decay = calculateDailyDecay(tasks);
        expect(decay.some(d => d.vector === VectorName.AURA)).toBe(true);
      });
      
      it('returns FAT increase when no cardio/strength', () => {
        const tasks = [
          TaskCategory.MEDITATION,
          TaskCategory.FACIAL,
          TaskCategory.JOURNAL
        ];
        const decay = calculateDailyDecay(tasks);
        const fatDecay = decay.find(d => d.vector === VectorName.FAT);
        expect(fatDecay?.operation).toBe('add'); // FAT aumenta
      });
    });
    
    describe('applyDecayToVectors', () => {
      it('applies decay respecting limits', () => {
        const state: VectorState = {
          aura_lvl: 1.00, // Ya en mÃ­nimo
          ...otros
        };
        const decay = [{ vector: VectorName.AURA, delta: 0.01, operation: 'subtract' }];
        const result = applyDecayToVectors(state, decay);
        expect(result.aura_lvl).toBe(1.00); // No baja de 1
      });
    });
  Criterio de Ã‰xito: "Todos los tests pasan"

TAREA-04.1.12:
  Nombre: "Implementar tests - scores"
  AcciÃ³n: "Tests de cÃ¡lculo de puntajes"
  Responsable: Antigravity
  Prompt para Antigravity: |
    ContinÃºa en vectors.test.ts:
    
    describe('calculatePhysiqueScore', () => {
      it('returns 1 for worst state (muscle=1, fat=13)', () => {
        expect(calculatePhysiqueScore(1, 13)).toBe(1);
      });
      
      it('returns 13 for best state (muscle=13, fat=1)', () => {
        expect(calculatePhysiqueScore(13, 1)).toBe(13);
      });
      
      it('returns 7 for middle state', () => {
        // muscle=7, fat=7 â†’ (7 + (14-7)) / 2 = (7+7)/2 = 7
        expect(calculatePhysiqueScore(7, 7)).toBe(7);
      });
    });
    
    describe('calculateOverallScore', () => {
      it('returns 1 for initial state', () => {
        const score = calculateOverallScore(INITIAL_VECTOR_STATE);
        expect(score).toBeCloseTo(1, 1);
      });
      
      it('returns 13 for perfect state', () => {
        const perfect: VectorState = {
          aura_lvl: 13,
          face_lvl: 13,
          wealth_lvl: 13,
          muscle_lvl: 13,
          fat_lvl: 1,
          env_lvl: 13
        };
        expect(calculateOverallScore(perfect)).toBeCloseTo(13, 1);
      });
    });
  Criterio de Ã‰xito: "Todos los tests pasan"

TAREA-04.1.13:
  Nombre: "Ejecutar suite completa de tests de vectores"
  AcciÃ³n: "Verificar que todos los tests pasan"
  Responsable: Antigravity
  Comando: |
    npm run test src/lib/core/vectors/vectors.test.ts
  Criterio de Ã‰xito: "100% de tests pasan, coverage > 90%"

SUBCAJA 04.2: SISTEMA DE NIVELES
CÃ¡lculo de ProgresiÃ³n del Usuario
Archivos a Crear
CopyRuta: /src/lib/core/levels/
â”œâ”€â”€ index.ts              (Exports pÃºblicos)
â”œâ”€â”€ types.ts              (Tipos de niveles)
â”œâ”€â”€ constants.ts          (DefiniciÃ³n de niveles)
â”œâ”€â”€ calculations.ts       (Funciones de cÃ¡lculo)
â””â”€â”€ levels.test.ts        (Tests unitarios)

TamaÃ±o Estimado: ~500 lÃ­neas total
Tiempo de GeneraciÃ³n: 45-60 minutos
Estructura del MÃ³dulo
Copy/src/lib/core/levels/
â”‚
â”œâ”€â”€ ğŸ“„ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ LevelNumber (type): 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
â”‚   â”‚
â”‚   â”œâ”€â”€ LevelName (enum)
â”‚   â”‚   â”œâ”€â”€ INDIGENTE = 1
â”‚   â”‚   â”œâ”€â”€ ARRIMADO = 2
â”‚   â”‚   â”œâ”€â”€ ALUCIN = 3
â”‚   â”‚   â”œâ”€â”€ CHALAN = 4
â”‚   â”‚   â”œâ”€â”€ GODIN = 5
â”‚   â”‚   â”œâ”€â”€ ACOMODADO = 6
â”‚   â”‚   â”œâ”€â”€ PUDIENTE = 7
â”‚   â”‚   â”œâ”€â”€ MILLONARIO = 8
â”‚   â”‚   â”œâ”€â”€ MAGNATE = 9
â”‚   â”‚   â”œâ”€â”€ SEMIDIOS = 10
â”‚   â”‚   â”œâ”€â”€ ELITE = 11
â”‚   â”‚   â”œâ”€â”€ LEYENDA = 12
â”‚   â”‚   â””â”€â”€ INMORTAL = 13
â”‚   â”‚
â”‚   â”œâ”€â”€ LevelInfo (interface)
â”‚   â”‚   â”œâ”€â”€ number: LevelNumber
â”‚   â”‚   â”œâ”€â”€ name: string
â”‚   â”‚   â”œâ”€â”€ title: string
â”‚   â”‚   â”œâ”€â”€ description: string
â”‚   â”‚   â”œâ”€â”€ minDay: number           // DÃ­a mÃ­nimo para alcanzar
â”‚   â”‚   â”œâ”€â”€ maxDay: number | null    // DÃ­a mÃ¡ximo (null = sin lÃ­mite)
â”‚   â”‚   â”œâ”€â”€ minOverallScore: number  // Score mÃ­nimo requerido
â”‚   â”‚   â”œâ”€â”€ isPostGame: boolean
â”‚   â”‚   â””â”€â”€ milestone?: MilestoneInfo
â”‚   â”‚
â”‚   â””â”€â”€ MilestoneInfo (interface)
â”‚       â”œâ”€â”€ type: 'video' | 'badge' | 'unlock'
â”‚       â”œâ”€â”€ description: string
â”‚       â””â”€â”€ content?: string
â”‚
â”œâ”€â”€ ğŸ“„ constants.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ LEVELS: Record<LevelNumber, LevelInfo>
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 1: INDIGENTE
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Indigente"
â”‚   â”‚   â”‚   â”œâ”€â”€ title: "El Punto MÃ¡s Bajo"
â”‚   â”‚   â”‚   â”œâ”€â”€ description: "Vives en la calle, sin rumbo ni recursos"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 1
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 2
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 1.0
â”‚   â”‚   â”‚   â”œâ”€â”€ isPostGame: false
â”‚   â”‚   â”‚   â””â”€â”€ milestone: { type: 'video', description: 'Avatar mirÃ¡ndose en charco' }
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 2: ARRIMADO
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Arrimado"
â”‚   â”‚   â”‚   â”œâ”€â”€ title: "Pidiendo Asilo"
â”‚   â”‚   â”‚   â”œâ”€â”€ description: "Un conocido te dio un rincÃ³n donde dormir"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 3
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 5
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 1.5
â”‚   â”‚   â”‚   â”œâ”€â”€ isPostGame: false
â”‚   â”‚   â”‚   â””â”€â”€ milestone: { type: 'video', description: 'Tocando puerta' }
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 3: ALUCÃN (HITO CRÃTICO)
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "AlucÃ­n"
â”‚   â”‚   â”‚   â”œâ”€â”€ title: "Fake It Till You Make It"
â”‚   â”‚   â”‚   â”œâ”€â”€ description: "Primer trabajo, primeras posesiones falsas"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 6  // Â¡DÃA DE CONVERSIÃ“N!
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 15
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 2.0
â”‚   â”‚   â”‚   â”œâ”€â”€ isPostGame: false
â”‚   â”‚   â”‚   â””â”€â”€ milestone: { 
â”‚   â”‚   â”‚         type: 'video', 
â”‚   â”‚   â”‚         description: 'PoniÃ©ndose gorra y cadena' 
â”‚   â”‚   â”‚       }
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 4: CHALÃN
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "ChalÃ¡n"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 16
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 30
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 2.5
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 5: GODÃN
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "GodÃ­n"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 31
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 45
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 3.5
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 6: ACOMODADO
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Acomodado"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 46
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 60
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 5.0
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 7: PUDIENTE
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Pudiente"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 61
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 75
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 6.5
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 8: MILLONARIO
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Millonario"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 76
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 85
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 8.0
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 9: MAGNATE
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Magnate"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 86
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 95
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 9.5
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 10: SEMI-DIOS
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Semi-Dios"
â”‚   â”‚   â”‚   â”œâ”€â”€ title: "Dominio Total"
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 96
â”‚   â”‚   â”‚   â”œâ”€â”€ maxDay: 100
â”‚   â”‚   â”‚   â”œâ”€â”€ minOverallScore: 11.0
â”‚   â”‚   â”‚   â”œâ”€â”€ isPostGame: false
â”‚   â”‚   â”‚   â””â”€â”€ milestone: { type: 'video', description: 'CelebraciÃ³n Ã©pica' }
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 11: Ã‰LITE (Post-Game)
â”‚   â”‚   â”‚   â”œâ”€â”€ minDay: 101
â”‚   â”‚   â”‚   â”œâ”€â”€ isPostGame: true
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ 12: LEYENDA (Post-Game)
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ 13: INMORTAL (Post-Game)
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”‚
â”‚   â”œâ”€â”€ ENV_LEVEL_BY_DAY
â”‚   â”‚   â”œâ”€â”€ 1-5: env_lvl 1
â”‚   â”‚   â”œâ”€â”€ 6-15: env_lvl 2
â”‚   â”‚   â”œâ”€â”€ 16-30: env_lvl 3
â”‚   â”‚   â”œâ”€â”€ 31-45: env_lvl 4
â”‚   â”‚   â”œâ”€â”€ 46-60: env_lvl 5
â”‚   â”‚   â”œâ”€â”€ 61-75: env_lvl 6-7
â”‚   â”‚   â”œâ”€â”€ 76-85: env_lvl 8-9
â”‚   â”‚   â”œâ”€â”€ 86-95: env_lvl 10-11
â”‚   â”‚   â””â”€â”€ 96-100: env_lvl 12-13
â”‚   â”‚
â”‚   â””â”€â”€ LEVEL_UP_BTC_BONUS
â”‚       â””â”€â”€ (nivel) => nivel * 100 BTC
â”‚
â”œâ”€â”€ ğŸ“„ calculations.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateLevel(
â”‚   â”‚     overallScore: number,
â”‚   â”‚     currentDay: number
â”‚   â”‚   ): LevelNumber
â”‚   â”‚   â”œâ”€â”€ Usa minOverallScore y minDay para determinar
â”‚   â”‚   â””â”€â”€ Retorna el nivel mÃ¡s alto que cumple ambos requisitos
â”‚   â”‚
â”‚   â”œâ”€â”€ getLevelInfo(level: LevelNumber): LevelInfo
â”‚   â”‚   â””â”€â”€ Retorna la informaciÃ³n completa del nivel
â”‚   â”‚
â”‚   â”œâ”€â”€ getNextLevel(currentLevel: LevelNumber): LevelInfo | null
â”‚   â”‚   â””â”€â”€ Retorna info del siguiente nivel (o null si es mÃ¡ximo)
â”‚   â”‚
â”‚   â”œâ”€â”€ getProgressToNextLevel(
â”‚   â”‚     currentLevel: LevelNumber,
â”‚   â”‚     overallScore: number,
â”‚   â”‚     currentDay: number
â”‚   â”‚   ): { scoreProgress: number, dayProgress: number }
â”‚   â”‚   â””â”€â”€ Porcentaje de progreso hacia el siguiente nivel
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateEnvLevel(currentDay: number): number
â”‚   â”‚   â””â”€â”€ Determina env_lvl basado en el dÃ­a
â”‚   â”‚
â”‚   â”œâ”€â”€ shouldLevelUp(
â”‚   â”‚     currentLevel: LevelNumber,
â”‚   â”‚     newOverallScore: number,
â”‚   â”‚     newDay: number
â”‚   â”‚   ): boolean
â”‚   â”‚   â””â”€â”€ Determina si el usuario debe subir de nivel
â”‚   â”‚
â”‚   â””â”€â”€ getLevelUpReward(newLevel: LevelNumber): number
â”‚       â””â”€â”€ BTC de bonus por subir a ese nivel
â”‚
â””â”€â”€ ğŸ“„ levels.test.ts
    â”‚
    â”œâ”€â”€ describe('calculateLevel')
    â”‚   â”œâ”€â”€ it('returns 1 for initial state')
    â”‚   â”œâ”€â”€ it('returns 3 (AlucÃ­n) at day 6 with score 2.0')
    â”‚   â”œâ”€â”€ it('respects day requirements')
    â”‚   â”œâ”€â”€ it('respects score requirements')
    â”‚   â””â”€â”€ it('returns max 10 for day 100')
    â”‚
    â”œâ”€â”€ describe('calculateEnvLevel')
    â”‚   â”œâ”€â”€ it('returns 1 for days 1-5')
    â”‚   â”œâ”€â”€ it('returns 2 for days 6-15')
    â”‚   â””â”€â”€ etc.
    â”‚
    â”œâ”€â”€ describe('shouldLevelUp')
    â”‚   â”œâ”€â”€ it('returns true when both requirements met')
    â”‚   â”œâ”€â”€ it('returns false when day not reached')
    â”‚   â””â”€â”€ it('returns false when score not reached')
    â”‚
    â””â”€â”€ describe('getProgressToNextLevel')
        â””â”€â”€ it('calculates percentage correctly')
Tareas AtÃ³micas para 04.2 Sistema de Niveles
yamlCopyTAREA-04.2.1:
  Nombre: "Crear estructura de carpetas para levels"
  AcciÃ³n: "Crear /src/lib/core/levels/ con archivos"
  Responsable: Antigravity
  Comando: |
    mkdir -p src/lib/core/levels
    touch src/lib/core/levels/{index,types,constants,calculations}.ts
    touch src/lib/core/levels/levels.test.ts
  Criterio de Ã‰xito: "Archivos existen"

TAREA-04.2.2:
  Nombre: "Implementar types.ts para levels"
  AcciÃ³n: "Definir tipos de niveles"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/levels/types.ts con:
    
    1. type LevelNumber = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
    
    2. enum LevelName con los nombres del cuestionario1:
       1=INDIGENTE, 2=ARRIMADO, 3=ALUCIN, 4=CHALAN, 5=GODIN,
       6=ACOMODADO, 7=PUDIENTE, 8=MILLONARIO, 9=MAGNATE, 10=SEMIDIOS,
       11=ELITE, 12=LEYENDA, 13=INMORTAL
    
    3. interface LevelInfo con todos los campos
    
    4. interface MilestoneInfo
    
    5. interface LevelProgress para tracking de progreso
  Criterio de Ã‰xito: "Tipos compilan"

TAREA-04.2.3:
  Nombre: "Implementar constants.ts para levels"
  AcciÃ³n: "Definir todos los niveles con sus propiedades"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/levels/constants.ts con LEVELS.
    
    Basado en cuestionario1, para cada nivel define:
    - number, name, title, description
    - minDay, maxDay (cuÃ¡ndo se puede alcanzar)
    - minOverallScore (score mÃ­nimo de vectores)
    - isPostGame (true para 11, 12, 13)
    - milestone (si aplica)
    
    NIVELES DEL CUESTIONARIO1:
    1. Indigente (dÃ­as 1-2, score 1.0)
    2. Arrimado (dÃ­as 3-5, score 1.5)
    3. AlucÃ­n (dÃ­as 6-15, score 2.0) - HITO DÃA 6
    4. ChalÃ¡n (dÃ­as 16-30, score 2.5)
    5. GodÃ­n (dÃ­as 31-45, score 3.5)
    6. Acomodado (dÃ­as 46-60, score 5.0)
    7. Pudiente (dÃ­as 61-75, score 6.5)
    8. Millonario (dÃ­as 76-85, score 8.0)
    9. Magnate (dÃ­as 86-95, score 9.5)
    10. Semi-Dios (dÃ­as 96-100, score 11.0)
    11-13: Post-game (dÃ­a 101+)
    
    TambiÃ©n define ENV_LEVEL_BY_DAY y LEVEL_UP_BTC_BONUS.
  Criterio de Ã‰xito: "13 niveles definidos correctamente"

TAREA-04.2.4:
  Nombre: "Implementar calculations.ts para levels"
  AcciÃ³n: "Funciones de cÃ¡lculo de nivel"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/levels/calculations.ts:
    
    1. calculateLevel(overallScore, currentDay): LevelNumber
       - Itera niveles de mayor a menor
       - Retorna el nivel mÃ¡s alto donde:
         * currentDay >= level.minDay
         * overallScore >= level.minOverallScore
       - Si ninguno cumple, retorna 1
    
    2. getLevelInfo(level): LevelInfo
    
    3. getNextLevel(currentLevel): LevelInfo | null
    
    4. getProgressToNextLevel(currentLevel, overallScore, currentDay)
       - Calcula % de progreso en score y dÃ­as
    
    5. calculateEnvLevel(currentDay): number
       - Mapea dÃ­a a nivel de entorno segÃºn ENV_LEVEL_BY_DAY
    
    6. shouldLevelUp(currentLevel, newOverallScore, newDay): boolean
    
    7. getLevelUpReward(newLevel): number
       - Retorna nivel * 100 BTC
  Criterio de Ã‰xito: "CÃ¡lculos correctos"

TAREA-04.2.5:
  Nombre: "Implementar index.ts para levels"
  AcciÃ³n: "Exports pÃºblicos"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Exports funcionan"

TAREA-04.2.6:
  Nombre: "Implementar tests de levels"
  AcciÃ³n: "Suite completa de tests"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/levels/levels.test.ts:
    
    describe('calculateLevel', () => {
      it('returns 1 for day 1 with initial score', () => {
        expect(calculateLevel(1.0, 1)).toBe(1);
      });
      
      it('returns 3 (AlucÃ­n) at day 6 with sufficient score', () => {
        expect(calculateLevel(2.0, 6)).toBe(3);
      });
      
      it('stays at lower level if score not sufficient', () => {
        // DÃ­a 6 pero score 1.5 (no alcanza 2.0 para AlucÃ­n)
        expect(calculateLevel(1.5, 6)).toBe(2);
      });
      
      it('cannot exceed level 10 before day 101', () => {
        expect(calculateLevel(13.0, 100)).toBe(10);
      });
      
      it('can reach level 11+ after day 100', () => {
        expect(calculateLevel(13.0, 101)).toBeGreaterThanOrEqual(11);
      });
    });
    
    describe('calculateEnvLevel', () => {
      it('returns 1 for days 1-5', () => {
        expect(calculateEnvLevel(1)).toBe(1);
        expect(calculateEnvLevel(5)).toBe(1);
      });
      
      it('returns 2 for days 6-15', () => {
        expect(calculateEnvLevel(6)).toBe(2);
        expect(calculateEnvLevel(15)).toBe(2);
      });
      
      // MÃ¡s tests para cada rango
    });
    
    describe('shouldLevelUp', () => {
      it('returns true when transitioning from 2 to 3 on day 6', () => {
        expect(shouldLevelUp(2, 2.0, 6)).toBe(true);
      });
      
      it('returns false if already at that level', () => {
        expect(shouldLevelUp(3, 2.5, 10)).toBe(false);
      });
    });
  Criterio de Ã‰xito: "Tests pasan"

TAREA-04.2.7:
  Nombre: "Ejecutar tests de levels"
  AcciÃ³n: "Verificar que todos pasan"
  Responsable: Antigravity
  Comando: |
    npm run test src/lib/core/levels/levels.test.ts
  Criterio de Ã‰xito: "100% tests pasan"

SUBCAJA 04.3: SISTEMA DE SALUD
Corazones y Supervivencia
Archivos a Crear
CopyRuta: /src/lib/core/health/
â”œâ”€â”€ index.ts
â”œâ”€â”€ types.ts
â”œâ”€â”€ constants.ts
â”œâ”€â”€ calculations.ts
â””â”€â”€ health.test.ts

TamaÃ±o Estimado: ~400 lÃ­neas
Tiempo de GeneraciÃ³n: 30-45 minutos
Estructura del MÃ³dulo
Copy/src/lib/core/health/
â”‚
â”œâ”€â”€ ğŸ“„ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ HealthStatus (enum)
â”‚   â”‚   â”œâ”€â”€ HEALTHY = 'healthy'     // 8-10 corazones
â”‚   â”‚   â”œâ”€â”€ INJURED = 'injured'     // 4-7 corazones
â”‚   â”‚   â”œâ”€â”€ CRITICAL = 'critical'   // 1-3 corazones
â”‚   â”‚   â””â”€â”€ DEAD = 'dead'           // 0 corazones
â”‚   â”‚
â”‚   â”œâ”€â”€ HealthState (interface)
â”‚   â”‚   â”œâ”€â”€ current: number         // 0-10 (o 0-13 post-game)
â”‚   â”‚   â”œâ”€â”€ max: number             // 10 base, 13 expandido
â”‚   â”‚   â””â”€â”€ status: HealthStatus
â”‚   â”‚
â”‚   â”œâ”€â”€ HealthChangeReason (enum)
â”‚   â”‚   â”œâ”€â”€ DAY_FAILED = 'day_failed'
â”‚   â”‚   â”œâ”€â”€ DAY_ZERO_TASKS = 'day_zero_tasks'
â”‚   â”‚   â”œâ”€â”€ STREAK_RECOVERY = 'streak_recovery'
â”‚   â”‚   â”œâ”€â”€ LIMBO_DECAY = 'limbo_decay'
â”‚   â”‚   â””â”€â”€ RESURRECTION = 'resurrection'
â”‚   â”‚
â”‚   â””â”€â”€ HealthChange (interface)
â”‚       â”œâ”€â”€ delta: number
â”‚       â”œâ”€â”€ reason: HealthChangeReason
â”‚       â””â”€â”€ newHealth: number
â”‚
â”œâ”€â”€ ğŸ“„ constants.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ HEALTH_CONFIG
â”‚   â”‚   â”œâ”€â”€ BASE_MAX: 10
â”‚   â”‚   â”œâ”€â”€ EXPANDED_MAX: 13
â”‚   â”‚   â”œâ”€â”€ MIN: 0
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ THRESHOLDS
â”‚   â”‚   â”‚   â”œâ”€â”€ HEALTHY: 8
â”‚   â”‚   â”‚   â”œâ”€â”€ INJURED: 4
â”‚   â”‚   â”‚   â””â”€â”€ CRITICAL: 1
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ DAMAGE
â”‚   â”‚   â”‚   â”œâ”€â”€ DAY_FAILED: -1
â”‚   â”‚   â”‚   â””â”€â”€ DAY_ZERO_TASKS: -2
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ RECOVERY
â”‚   â”‚   â”‚   â””â”€â”€ STREAK_7_DAYS: +1
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ LIMBO_DECAY
â”‚   â”‚       â”œâ”€â”€ DAYS_PER_HEART: 3
â”‚   â”‚       â””â”€â”€ DAMAGE_PER_INTERVAL: -1
â”‚   â”‚
â”‚   â””â”€â”€ INITIAL_HEALTH_STATE
â”‚       â”œâ”€â”€ current: 10
â”‚       â”œâ”€â”€ max: 10
â”‚       â””â”€â”€ status: HEALTHY
â”‚
â”œâ”€â”€ ğŸ“„ calculations.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ getHealthStatus(current: number, max: number): HealthStatus
â”‚   â”‚   â”œâ”€â”€ 0 â†’ DEAD
â”‚   â”‚   â”œâ”€â”€ 1-3 â†’ CRITICAL
â”‚   â”‚   â”œâ”€â”€ 4-7 â†’ INJURED
â”‚   â”‚   â””â”€â”€ 8+ â†’ HEALTHY
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateHealthChange(
â”‚   â”‚     currentHealth: number,
â”‚   â”‚     reason: HealthChangeReason
â”‚   â”‚   ): HealthChange
â”‚   â”‚   â””â”€â”€ Calcula el cambio basado en la razÃ³n
â”‚   â”‚
â”‚   â”œâ”€â”€ applyHealthChange(
â”‚   â”‚     state: HealthState,
â”‚   â”‚     change: HealthChange
â”‚   â”‚   ): HealthState
â”‚   â”‚   â””â”€â”€ Aplica cambio respetando lÃ­mites
â”‚   â”‚
â”‚   â”œâ”€â”€ canRecoverHealth(
â”‚   â”‚     currentHealth: number,
â”‚   â”‚     maxHealth: number,
â”‚   â”‚     streakDays: number
â”‚   â”‚   ): boolean
â”‚   â”‚   â””â”€â”€ True si streak >= 7 y current < max
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateLimboHealthLoss(
â”‚   â”‚     daysSinceLimbo: number
â”‚   â”‚   ): number
â”‚   â”‚   â””â”€â”€ Calcula corazones perdidos en limbo
â”‚   â”‚
â”‚   â”œâ”€â”€ isDead(health: number): boolean
â”‚   â”‚   â””â”€â”€ health <= 0
â”‚   â”‚
â”‚   â””â”€â”€ getHealthDisplayInfo(state: HealthState): HealthDisplayInfo
â”‚       â””â”€â”€ Info para UI (color, icono, mensaje)
â”‚
â””â”€â”€ ğŸ“„ health.test.ts
    â”‚
    â”œâ”€â”€ describe('getHealthStatus')
    â”œâ”€â”€ describe('calculateHealthChange')
    â”œâ”€â”€ describe('applyHealthChange')
    â”œâ”€â”€ describe('canRecoverHealth')
    â””â”€â”€ describe('calculateLimboHealthLoss')
Tareas AtÃ³micas para 04.3 Sistema de Salud
yamlCopyTAREA-04.3.1:
  Nombre: "Crear estructura de carpetas para health"
  AcciÃ³n: "Crear /src/lib/core/health/ con archivos"
  Responsable: Antigravity
  Comando: |
    mkdir -p src/lib/core/health
    touch src/lib/core/health/{index,types,constants,calculations}.ts
    touch src/lib/core/health/health.test.ts
  Criterio de Ã‰xito: "Archivos existen"

TAREA-04.3.2:
  Nombre: "Implementar types.ts para health"
  AcciÃ³n: "Definir tipos de salud"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/health/types.ts:
    
    1. enum HealthStatus: HEALTHY, INJURED, CRITICAL, DEAD
    2. interface HealthState: { current, max, status }
    3. enum HealthChangeReason: DAY_FAILED, DAY_ZERO_TASKS, 
       STREAK_RECOVERY, LIMBO_DECAY, RESURRECTION
    4. interface HealthChange: { delta, reason, newHealth }
    5. interface HealthDisplayInfo: { color, icon, message, percentage }
  Criterio de Ã‰xito: "Tipos compilan"

TAREA-04.3.3:
  Nombre: "Implementar constants.ts para health"
  AcciÃ³n: "Definir constantes de salud"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/health/constants.ts:
    
    HEALTH_CONFIG con:
    - BASE_MAX: 10, EXPANDED_MAX: 13, MIN: 0
    - THRESHOLDS: { HEALTHY: 8, INJURED: 4, CRITICAL: 1 }
    - DAMAGE: { DAY_FAILED: -1, DAY_ZERO_TASKS: -2 }
    - RECOVERY: { STREAK_7_DAYS: +1 }
    - LIMBO_DECAY: { DAYS_PER_HEART: 3, DAMAGE: -1 }
    
    INITIAL_HEALTH_STATE con current: 10, max: 10
  Criterio de Ã‰xito: "Constantes exportan"

TAREA-04.3.4:
  Nombre: "Implementar calculations.ts para health"
  AcciÃ³n: "Funciones de cÃ¡lculo de salud"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/health/calculations.ts:
    
    1. getHealthStatus(current, max): HealthStatus
    2. calculateHealthChange(currentHealth, reason): HealthChange
    3. applyHealthChange(state, change): HealthState (inmutable)
    4. canRecoverHealth(currentHealth, maxHealth, streakDays): boolean
    5. calculateLimboHealthLoss(daysSinceLimbo): number
    6. isDead(health): boolean
    7. getHealthDisplayInfo(state): objeto para UI
    
    REGLAS DEL CUESTIONARIO1:
    - < 80% completado = -1 corazÃ³n
    - 0% completado = -2 corazones
    - Racha 7 dÃ­as + 100% dÃ­a = +1 corazÃ³n (si < max)
    - Limbo: -1 corazÃ³n cada 3 dÃ­as
  Criterio de Ã‰xito: "LÃ³gica correcta"

TAREA-04.3.5:
  Nombre: "Implementar index.ts para health"
  AcciÃ³n: "Exports pÃºblicos"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Exports funcionan"

TAREA-04.3.6:
  Nombre: "Implementar tests de health"
  AcciÃ³n: "Suite completa de tests"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Crea /src/lib/core/health/health.test.ts:
    
    describe('getHealthStatus', () => {
      it('returns DEAD for 0', () => {
        expect(getHealthStatus(0, 10)).toBe(HealthStatus.DEAD);
      });
      it('returns CRITICAL for 1-3', () => {...});
      it('returns INJURED for 4-7', () => {...});
      it('returns HEALTHY for 8+', () => {...});
    });
    
    describe('calculateHealthChange', () => {
      it('returns -1 for DAY_FAILED', () => {...});
      it('returns -2 for DAY_ZERO_TASKS', () => {...});
      it('returns +1 for STREAK_RECOVERY', () => {...});
    });
    
    describe('applyHealthChange', () => {
      it('does not go below 0', () => {
        const state = { current: 1, max: 10, status: HealthStatus.CRITICAL };
        const change = { delta: -2, reason: HealthChangeReason.DAY_FAILED, newHealth: -1 };
        const result = applyHealthChange(state, change);
        expect(result.current).toBe(0);
        expect(result.status).toBe(HealthStatus.DEAD);
      });
      
      it('does not exceed max', () => {...});
    });
    
    describe('canRecoverHealth', () => {
      it('returns true when streak >= 7 and health < max', () => {
        expect(canRecoverHealth(9, 10, 7)).toBe(true);
      });
      it('returns false when already at max', () => {
        expect(canRecoverHealth(10, 10, 10)).toBe(false);
      });
      it('returns false when streak < 7', () => {
        expect(canRecoverHealth(5, 10, 6)).toBe(false);
      });
    });
  Criterio de Ã‰xito: "Tests pasan"

TAREA-04.3.7:
  Nombre: "Ejecutar tests de health"
  AcciÃ³n: "Verificar tests"
  Responsable: Antigravity
  Comando: npm run test src/lib/core/health/health.test.ts
  Criterio de Ã‰xito: "100% pasan"

SUBCAJA 04.4: SISTEMA DE RACHA
Streak y Multiplicadores
Archivos a Crear
CopyRuta: /src/lib/core/streak/
â”œâ”€â”€ index.ts
â”œâ”€â”€ types.ts
â”œâ”€â”€ constants.ts
â”œâ”€â”€ calculations.ts
â””â”€â”€ streak.test.ts

TamaÃ±o Estimado: ~350 lÃ­neas
Tiempo de GeneraciÃ³n: 25-35 minutos
Estructura del MÃ³dulo
Copy/src/lib/core/streak/
â”‚
â”œâ”€â”€ ğŸ“„ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ StreakTier (enum)
â”‚   â”‚   â”œâ”€â”€ NONE = 'none'           // 0 dÃ­as
â”‚   â”‚   â”œâ”€â”€ STARTING = 'starting'   // 1-6 dÃ­as
â”‚   â”‚   â”œâ”€â”€ BUILDING = 'building'   // 7-13 dÃ­as
â”‚   â”‚   â”œâ”€â”€ SOLID = 'solid'         // 14-20 dÃ­as
â”‚   â”‚   â”œâ”€â”€ STRONG = 'strong'       // 21-29 dÃ­as
â”‚   â”‚   â”œâ”€â”€ IRON = 'iron'           // 30-59 dÃ­as
â”‚   â”‚   â”œâ”€â”€ DIAMOND = 'diamond'     // 60-89 dÃ­as
â”‚   â”‚   â””â”€â”€ LEGENDARY = 'legendary' // 90+ dÃ­as
â”‚   â”‚
â”‚   â”œâ”€â”€ StreakState (interface)
â”‚   â”‚   â”œâ”€â”€ days: number
â”‚   â”‚   â”œâ”€â”€ tier: StreakTier
â”‚   â”‚   â”œâ”€â”€ multiplier: number
â”‚   â”‚   â””â”€â”€ nextMilestone: number | null
â”‚   â”‚
â”‚   â”œâ”€â”€ StreakMilestone (interface)
â”‚   â”‚   â”œâ”€â”€ days: number
â”‚   â”‚   â”œâ”€â”€ reward: StreakReward
â”‚   â”‚   â””â”€â”€ description: string
â”‚   â”‚
â”‚   â””â”€â”€ StreakReward (interface)
â”‚       â”œâ”€â”€ btcBonus: number
â”‚       â”œâ”€â”€ healthRecovery?: boolean
â”‚       â””â”€â”€ badge?: string
â”‚
â”œâ”€â”€ ğŸ“„ constants.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ STREAK_MULTIPLIERS
â”‚   â”‚   â”œâ”€â”€ 0-6: 1.0
â”‚   â”‚   â”œâ”€â”€ 7-13: 1.1
â”‚   â”‚   â”œâ”€â”€ 14-20: 1.2
â”‚   â”‚   â”œâ”€â”€ 21-29: 1.3
â”‚   â”‚   â”œâ”€â”€ 30-59: 1.5
â”‚   â”‚   â”œâ”€â”€ 60-89: 1.75
â”‚   â”‚   â””â”€â”€ 90+: 2.0
â”‚   â”‚
â”‚   â”œâ”€â”€ STREAK_MILESTONES
â”‚   â”‚   â”œâ”€â”€ 7: { btcBonus: 0, healthRecovery: true }
â”‚   â”‚   â”œâ”€â”€ 14: { btcBonus: 500 }
â”‚   â”‚   â”œâ”€â”€ 30: { btcBonus: 1500, badge: 'Monthly Master' }
â”‚   â”‚   â”œâ”€â”€ 60: { btcBonus: 3000 }
â”‚   â”‚   â””â”€â”€ 100: { btcBonus: 10000, badge: 'Centurion' }
â”‚   â”‚
â”‚   â””â”€â”€ STREAK_TIER_THRESHOLDS
â”‚
â”œâ”€â”€ ğŸ“„ calculations.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateMultiplier(streakDays: number): number
â”‚   â”‚
â”‚   â”œâ”€â”€ getStreakTier(streakDays: number): StreakTier
â”‚   â”‚
â”‚   â”œâ”€â”€ getStreakState(streakDays: number): StreakState
â”‚   â”‚
â”‚   â”œâ”€â”€ processSuccessfulDay(currentStreak: number): {
â”‚   â”‚     newStreak: number,
â”‚   â”‚     milestone: StreakMilestone | null
â”‚   â”‚   }
â”‚   â”‚
â”‚   â”œâ”€â”€ processFailedDay(): { newStreak: 0 }
â”‚   â”‚
â”‚   â”œâ”€â”€ getNextMilestone(currentStreak: number): number | null
â”‚   â”‚
â”‚   â”œâ”€â”€ applyMultiplierToBtc(
â”‚   â”‚     baseBtc: number,
â”‚   â”‚     streakDays: number
â”‚   â”‚   ): number
â”‚   â”‚
â”‚   â””â”€â”€ getMilestoneIfReached(
â”‚       previousStreak: number,
â”‚       newStreak: number
â”‚     ): StreakMilestone | null
â”‚
â””â”€â”€ ğŸ“„ streak.test.ts
Tareas AtÃ³micas para 04.4 Sistema de Racha
yamlCopyTAREA-04.4.1:
  Nombre: "Crear estructura para streak"
  AcciÃ³n: "Crear archivos"
  Responsable: Antigravity
  Comando: |
    mkdir -p src/lib/core/streak
    touch src/lib/core/streak/{index,types,constants,calculations}.ts
    touch src/lib/core/streak/streak.test.ts
  Criterio de Ã‰xito: "Archivos existen"

TAREA-04.4.2:
  Nombre: "Implementar types.ts para streak"
  AcciÃ³n: "Definir tipos"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Tipos compilan"

TAREA-04.4.3:
  Nombre: "Implementar constants.ts para streak"
  AcciÃ³n: "Definir multiplicadores y milestones"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Basado en cuestionario1:
    - Multiplicadores: 1.0, 1.1, 1.2, 1.3, 1.5, 1.75, 2.0
    - Milestone 7 dÃ­as: recuperaciÃ³n de salud
    - Milestone 30: +1500 BTC, badge
    - Milestone 100: +10000 BTC, badge especial
  Criterio de Ã‰xito: "Constantes definidas"

TAREA-04.4.4:
  Nombre: "Implementar calculations.ts para streak"
  AcciÃ³n: "Funciones de cÃ¡lculo"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Funciones:
    1. calculateMultiplier(streakDays): busca en STREAK_MULTIPLIERS
    2. getStreakTier(streakDays): determina tier
    3. getStreakState(streakDays): estado completo
    4. processSuccessfulDay(currentStreak): incrementa, detecta milestone
    5. processFailedDay(): retorna { newStreak: 0 }
    6. applyMultiplierToBtc(baseBtc, streakDays): base * multiplier
    7. getMilestoneIfReached(prev, new): detecta si cruzÃ³ milestone
  Criterio de Ã‰xito: "LÃ³gica correcta"

TAREA-04.4.5:
  Nombre: "Implementar index.ts y tests para streak"
  AcciÃ³n: "Exports y tests"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Tests pasan"

SUBCAJA 04.5: JUDGEMENT NIGHT
LÃ³gica de Cierre del DÃ­a
Archivos a Crear
CopyRuta: /src/lib/core/judgement/
â”œâ”€â”€ index.ts
â”œâ”€â”€ types.ts
â”œâ”€â”€ constants.ts
â”œâ”€â”€ processor.ts
â””â”€â”€ judgement.test.ts

TamaÃ±o Estimado: ~600 lÃ­neas
Tiempo de GeneraciÃ³n: 45-60 minutos
Estructura del MÃ³dulo
Copy/src/lib/core/judgement/
â”‚
â”œâ”€â”€ ğŸ“„ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ DayStatus (enum)
â”‚   â”‚   â”œâ”€â”€ SUCCESS = 'success'     // 100% completado
â”‚   â”‚   â”œâ”€â”€ PARTIAL = 'partial'     // 80-99% completado
â”‚   â”‚   â”œâ”€â”€ FAILED = 'failed'       // < 80% completado
â”‚   â”‚   â””â”€â”€ DEATH = 'death'         // Salud llegÃ³ a 0
â”‚   â”‚
â”‚   â”œâ”€â”€ JudgementInput (interface)
â”‚   â”‚   â”œâ”€â”€ currentDay: number
â”‚   â”‚   â”œâ”€â”€ completedTasks: TaskCategory[]
â”‚   â”‚   â”œâ”€â”€ totalRequiredTasks: number
â”‚   â”‚   â”œâ”€â”€ currentVectors: VectorState
â”‚   â”‚   â”œâ”€â”€ currentHealth: HealthState
â”‚   â”‚   â”œâ”€â”€ currentStreak: number
â”‚   â”‚   â””â”€â”€ isPostGame: boolean
â”‚   â”‚
â”‚   â”œâ”€â”€ JudgementResult (interface)
â”‚   â”‚   â”œâ”€â”€ status: DayStatus
â”‚   â”‚   â”œâ”€â”€ completionRate: number
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ vectorChanges: VectorDelta
â”‚   â”‚   â”œâ”€â”€ newVectors: VectorState
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ healthChange: HealthChange | null
â”‚   â”‚   â”œâ”€â”€ newHealth: HealthState
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ streakChange: { previous: number, new: number }
â”‚   â”‚   â”œâ”€â”€ streakMilestone: StreakMilestone | null
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ btcEarned: number
â”‚   â”‚   â”œâ”€â”€ btcFromTasks: number
â”‚   â”‚   â”œâ”€â”€ btcFromMultiplier: number
â”‚   â”‚   â”œâ”€â”€ btcFromBonuses: number
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ levelChange: { previous: number, new: number } | null
â”‚   â”‚   â”œâ”€â”€ envChange: { previous: number, new: number } | null
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ isDead: boolean
â”‚   â”‚   â””â”€â”€ shouldGenerateImage: boolean
â”‚   â”‚
â”‚   â””â”€â”€ DayLogEntry (interface)
â”‚       â””â”€â”€ Para persistir en daily_logs
â”‚
â”œâ”€â”€ ğŸ“„ constants.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ COMPLETION_THRESHOLDS
â”‚   â”‚   â”œâ”€â”€ SUCCESS: 1.00 (100%)
â”‚   â”‚   â”œâ”€â”€ PARTIAL: 0.80 (80%)
â”‚   â”‚   â””â”€â”€ FAILED: < 0.80
â”‚   â”‚
â”‚   â”œâ”€â”€ DAY_BONUSES
â”‚   â”‚   â”œâ”€â”€ PERFECT_DAY: 50 BTC
â”‚   â”‚   â””â”€â”€ LEVEL_UP: (nivel) => nivel * 100 BTC
â”‚   â”‚
â”‚   â””â”€â”€ IMAGE_GENERATION_PRIORITY
â”‚       â”œâ”€â”€ SUCCESS: 'high'
â”‚       â”œâ”€â”€ PARTIAL: 'normal'
â”‚       â””â”€â”€ FAILED: 'low'
â”‚
â”œâ”€â”€ ğŸ“„ processor.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ calculateCompletionRate(
â”‚   â”‚     completed: number,
â”‚   â”‚     total: number
â”‚   â”‚   ): number
â”‚   â”‚
â”‚   â”œâ”€â”€ determineDayStatus(
â”‚   â”‚     completionRate: number,
â”‚   â”‚     healthAfterPenalty: number
â”‚   â”‚   ): DayStatus
â”‚   â”‚
â”‚   â”œâ”€â”€ processJudgementNight(input: JudgementInput): JudgementResult
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 1: Calcular completion rate
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 2: Aplicar tareas a vectores
â”‚   â”‚   â”‚   â””â”€â”€ Usar applyMultipleTasksToVectors()
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 3: Calcular y aplicar decay
â”‚   â”‚   â”‚   â””â”€â”€ Usar calculateDailyDecay() y applyDecayToVectors()
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 4: Procesar racha
â”‚   â”‚   â”‚   â”œâ”€â”€ Si completionRate >= 0.80: processSuccessfulDay()
â”‚   â”‚   â”‚   â””â”€â”€ Si no: processFailedDay()
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 5: Calcular cambio de salud
â”‚   â”‚   â”‚   â”œâ”€â”€ Si < 0.80: -1 corazÃ³n
â”‚   â”‚   â”‚   â”œâ”€â”€ Si = 0: -2 corazones
â”‚   â”‚   â”‚   â”œâ”€â”€ Si racha milestone 7: puede +1 corazÃ³n
â”‚   â”‚   â”‚   â””â”€â”€ Aplicar cambio
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 6: Verificar muerte
â”‚   â”‚   â”‚   â””â”€â”€ Si health = 0: status = DEATH
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 7: Calcular BTC
â”‚   â”‚   â”‚   â”œâ”€â”€ btcFromTasks = calculateTotalBtcFromTasks()
â”‚   â”‚   â”‚   â”œâ”€â”€ btcFromMultiplier = aplicar multiplicador de racha
â”‚   â”‚   â”‚   â”œâ”€â”€ btcFromBonuses = dÃ­a perfecto + nivel up
â”‚   â”‚   â”‚   â””â”€â”€ btcEarned = suma de todo
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 8: Calcular nuevo nivel
â”‚   â”‚   â”‚   â””â”€â”€ Usar calculateLevel() y shouldLevelUp()
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 9: Calcular nuevo env
â”‚   â”‚   â”‚   â””â”€â”€ Usar calculateEnvLevel()
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ PASO 10: Construir resultado
â”‚   â”‚
â”‚   â”œâ”€â”€ createDayLogEntry(
â”‚   â”‚     input: JudgementInput,
â”‚   â”‚     result: JudgementResult
â”‚   â”‚   ): DayLogEntry
â”‚   â”‚
â”‚   â””â”€â”€ getImageGenerationPriority(status: DayStatus): string
â”‚
â””â”€â”€ ğŸ“„ judgement.test.ts
    â”‚
    â”œâ”€â”€ describe('calculateCompletionRate')
    â”‚   â”œâ”€â”€ it('returns 1.0 for 5/5')
    â”‚   â”œâ”€â”€ it('returns 0.8 for 4/5')
    â”‚   â””â”€â”€ it('returns 0.6 for 3/5')
    â”‚
    â”œâ”€â”€ describe('determineDayStatus')
    â”‚   â”œâ”€â”€ it('returns SUCCESS for 1.0')
    â”‚   â”œâ”€â”€ it('returns PARTIAL for 0.8-0.99')
    â”‚   â”œâ”€â”€ it('returns FAILED for < 0.8')
    â”‚   â””â”€â”€ it('returns DEATH if health becomes 0')
    â”‚
    â””â”€â”€ describe('processJudgementNight')
        â”œâ”€â”€ it('processes a perfect day correctly')
        â”œâ”€â”€ it('processes a partial day correctly')
        â”œâ”€â”€ it('processes a failed day with health loss')
        â”œâ”€â”€ it('triggers level up when conditions met')
        â”œâ”€â”€ it('triggers streak milestone when reached')
        â””â”€â”€ it('triggers death when health reaches 0')
Tareas AtÃ³micas para 04.5 Judgement Night
yamlCopyTAREA-04.5.1:
  Nombre: "Crear estructura para judgement"
  AcciÃ³n: "Crear archivos"
  Responsable: Antigravity
  Comando: |
    mkdir -p src/lib/core/judgement
    touch src/lib/core/judgement/{index,types,constants,processor}.ts
    touch src/lib/core/judgement/judgement.test.ts
  Criterio de Ã‰xito: "Archivos existen"

TAREA-04.5.2:
  Nombre: "Implementar types.ts para judgement"
  AcciÃ³n: "Definir tipos"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Tipos compilan"

TAREA-04.5.3:
  Nombre: "Implementar constants.ts para judgement"
  AcciÃ³n: "Definir constantes"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Constantes exportan"

TAREA-04.5.4:
  Nombre: "Implementar processor.ts - Funciones auxiliares"
  AcciÃ³n: "calculateCompletionRate, determineDayStatus"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Implementa:
    1. calculateCompletionRate(completed, total): number
       - completed / total, maneja divisiÃ³n por cero
    
    2. determineDayStatus(completionRate, healthAfterPenalty): DayStatus
       - 1.0 â†’ SUCCESS
       - 0.8-0.99 â†’ PARTIAL
       - < 0.8 â†’ FAILED
       - Si healthAfterPenalty <= 0 â†’ DEATH
  Criterio de Ã‰xito: "Funciones correctas"

TAREA-04.5.5:
  Nombre: "Implementar processor.ts - processJudgementNight"
  AcciÃ³n: "FunciÃ³n principal del mÃ³dulo"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Implementa processJudgementNight(input: JudgementInput): JudgementResult
    
    Esta es LA funciÃ³n mÃ¡s importante del motor core.
    Debe:
    1. Calcular completion rate
    2. Aplicar tareas completadas a vectores
    3. Calcular y aplicar decay biolÃ³gico
    4. Procesar racha (incrementar o resetear)
    5. Calcular cambio de salud
    6. Verificar muerte
    7. Calcular BTC ganados (con multiplicadores)
    8. Verificar level up
    9. Calcular nuevo env_lvl
    10. Construir y retornar resultado completo
    
    USA las funciones de los otros mÃ³dulos:
    - applyMultipleTasksToVectors, calculateDailyDecay, applyDecayToVectors
    - processSuccessfulDay, processFailedDay, applyMultiplierToBtc
    - calculateHealthChange, applyHealthChange, isDead
    - calculateOverallScore, calculateLevel, shouldLevelUp
    - calculateEnvLevel
    
    La funciÃ³n debe ser PURA - solo cÃ¡lculos, sin side effects.
  Criterio de Ã‰xito: "Proceso completo funciona"

TAREA-04.5.6:
  Nombre: "Implementar tests de judgement"
  AcciÃ³n: "Suite completa"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Tests crÃ­ticos:
    
    1. DÃ­a perfecto (100%):
       - Vectores suben
       - Racha incrementa
       - Salud no cambia (o +1 si milestone 7)
       - BTC con multiplicador
       - Status: SUCCESS
    
    2. DÃ­a parcial (80-99%):
       - Vectores suben parcialmente
       - Racha incrementa
       - Salud no cambia
       - Status: PARTIAL
    
    3. DÃ­a fallido (< 80%):
       - Vectores con decay
       - Racha = 0
       - Salud -1
       - Status: FAILED
    
    4. DÃ­a que causa muerte:
       - Usuario con 1 corazÃ³n que falla
       - Salud â†’ 0
       - Status: DEATH
    
    5. Level up:
       - DÃ­a 6, score suficiente
       - Level 2 â†’ 3 (AlucÃ­n)
       - BTC bonus de nivel
    
    6. Streak milestone:
       - Racha 6 â†’ 7
       - Health recovery trigger
  Criterio de Ã‰xito: "Tests pasan"

TAREA-04.5.7:
  Nombre: "Implementar index.ts y ejecutar tests"
  AcciÃ³n: "Exports y verificaciÃ³n"
  Responsable: Antigravity
  Comando: npm run test src/lib/core/judgement/judgement.test.ts
  Criterio de Ã‰xito: "100% tests pasan"

SUBCAJA 04.6: MUERTE Y RESURRECCIÃ“N
Reset del Avatar
Archivos a Crear
CopyRuta: /src/lib/core/death/
â”œâ”€â”€ index.ts
â”œâ”€â”€ types.ts
â”œâ”€â”€ constants.ts
â”œâ”€â”€ processor.ts
â””â”€â”€ death.test.ts

TamaÃ±o Estimado: ~350 lÃ­neas
Tiempo de GeneraciÃ³n: 25-35 minutos
Estructura del MÃ³dulo
Copy/src/lib/core/death/
â”‚
â”œâ”€â”€ ğŸ“„ types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ DeathCause (enum)
â”‚   â”‚   â”œâ”€â”€ HEALTH_DEPLETED = 'health_depleted'
â”‚   â”‚   â””â”€â”€ LIMBO_EXPIRED = 'limbo_expired'
â”‚   â”‚
â”‚   â”œâ”€â”€ DeathState (interface)
â”‚   â”‚   â”œâ”€â”€ cause: DeathCause
â”‚   â”‚   â”œâ”€â”€ dayOfDeath: number
â”‚   â”‚   â””â”€â”€ timestamp: Date
â”‚   â”‚
â”‚   â”œâ”€â”€ ResurrectionResult (interface)
â”‚   â”‚   â”œâ”€â”€ newVectors: VectorState
â”‚   â”‚   â”œâ”€â”€ newHealth: HealthState
â”‚   â”‚   â”œâ”€â”€ newStreak: number
â”‚   â”‚   â”œâ”€â”€ newDay: number
â”‚   â”‚   â”œâ”€â”€ newLevel: number
â”‚   â”‚   â”œâ”€â”€ btcRetained: number
â”‚   â”‚   â”œâ”€â”€ inventoryLocked: InventoryItem[]
â”‚   â”‚   â””â”€â”€ vectorsRetained: Partial<VectorState>
â”‚   â”‚
â”‚   â””â”€â”€ DeathReport (interface)
â”‚       â”œâ”€â”€ whatWasLost: string[]
â”‚       â”œâ”€â”€ whatWasKept: string[]
â”‚       â””â”€â”€ motivationalMessage: string
â”‚
â”œâ”€â”€ ğŸ“„ constants.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ DEATH_RESET_CONFIG
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ VECTORS_RESET (Lo que se resetea a inicial)
â”‚   â”‚   â”‚   â”œâ”€â”€ fat_lvl: 13.00
â”‚   â”‚   â”‚   â”œâ”€â”€ muscle_lvl: 1.00
â”‚   â”‚   â”‚   â””â”€â”€ health_points: 10
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ VECTORS_RETAINED (Lo que se conserva)
â”‚   â”‚   â”‚   â”œâ”€â”€ aura_lvl: true  (progreso mental)
â”‚   â”‚   â”‚   â”œâ”€â”€ face_lvl: true  (progreso facial)
â”‚   â”‚   â”‚   â””â”€â”€ wealth_lvl: true (progreso productivo)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ STATS_RESET
â”‚   â”‚   â”‚   â”œâ”€â”€ streak_days: 0
â”‚   â”‚   â”‚   â”œâ”€â”€ current_day: 1
â”‚   â”‚   â”‚   â””â”€â”€ current_level: 1
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ENV_PENALTY: -3 niveles (mÃ­nimo 1)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ BTC_PENALTY: 0 (sin penalizaciÃ³n de BTC)
â”‚   â”‚
â”‚   â””â”€â”€ DEATH_MESSAGES
â”‚       â””â”€â”€ Array de mensajes motivacionales
â”‚
â”œâ”€â”€ ğŸ“„ processor.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ processAvatarDeath(
â”‚   â”‚     currentState: FullUserState,
â”‚   â”‚     cause: DeathCause
â”‚   â”‚   ): ResurrectionResult
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 1: Resetear vectores fÃ­sicos
â”‚   â”‚   â”‚   â”œâ”€â”€ fat_lvl â†’ 13.00
â”‚   â”‚   â”‚   â””â”€â”€ muscle_lvl â†’ 1.00
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 2: Conservar vectores mentales
â”‚   â”‚   â”‚   â”œâ”€â”€ aura_lvl â†’ mantener
â”‚   â”‚   â”‚   â”œâ”€â”€ face_lvl â†’ mantener
â”‚   â”‚   â”‚   â””â”€â”€ wealth_lvl â†’ mantener
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 3: Resetear stats
â”‚   â”‚   â”‚   â”œâ”€â”€ health â†’ 10/10
â”‚   â”‚   â”‚   â”œâ”€â”€ streak â†’ 0
â”‚   â”‚   â”‚   â”œâ”€â”€ current_day â†’ 1
â”‚   â”‚   â”‚   â””â”€â”€ current_level â†’ 1
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 4: Penalizar entorno
â”‚   â”‚   â”‚   â””â”€â”€ env_lvl = max(1, env_lvl - 3)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ PASO 5: Conservar BTC
â”‚   â”‚   â”‚   â””â”€â”€ Sin penalizaciÃ³n
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ PASO 6: Bloquear inventario
â”‚   â”‚       â””â”€â”€ Items con level_required > 1 se bloquean
â”‚   â”‚
â”‚   â”œâ”€â”€ getLockedInventoryItems(
â”‚   â”‚     inventory: InventoryItem[],
â”‚   â”‚     newLevel: number
â”‚   â”‚   ): InventoryItem[]
â”‚   â”‚
â”‚   â”œâ”€â”€ generateDeathReport(
â”‚   â”‚     beforeState: FullUserState,
â”‚   â”‚     afterState: ResurrectionResult
â”‚   â”‚   ): DeathReport
â”‚   â”‚
â”‚   â””â”€â”€ canEquipItemAfterDeath(
â”‚       item: StoreItem,
â”‚       newLevel: number
â”‚     ): boolean
â”‚
â””â”€â”€ ğŸ“„ death.test.ts
Tareas AtÃ³micas para 04.6 Muerte y ResurrecciÃ³n
yamlCopyTAREA-04.6.1:
  Nombre: "Crear estructura para death"
  AcciÃ³n: "Crear archivos"
  Responsable: Antigravity
  Comando: |
    mkdir -p src/lib/core/death
    touch src/lib/core/death/{index,types,constants,processor}.ts
    touch src/lib/core/death/death.test.ts
  Criterio de Ã‰xito: "Archivos existen"

TAREA-04.6.2:
  Nombre: "Implementar types.ts para death"
  AcciÃ³n: "Definir tipos"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Tipos compilan"

TAREA-04.6.3:
  Nombre: "Implementar constants.ts para death"
  AcciÃ³n: "Definir configuraciÃ³n de reset"
  Responsable: Antigravity
  Prompt para Antigravity: |
    Basado en cuestionario1:
    
    QUE SE RESETEA:
    - fat_lvl â†’ 13.00 (vuelve a gordo)
    - muscle_lvl â†’ 1.00 (pierde mÃºsculo)
    - health_points â†’ 10 (salud completa)
    - streak_days â†’ 0
    - current_day â†’ 1 (reinicia protocolo)
    - current_level â†’ 1
    
    QUE SE CONSERVA:
    - aura_lvl (progreso mental)
    - face_lvl (progreso facial/lookmaxing)
    - wealth_lvl (progreso productivo)
    - BTC en wallet (sin penalizaciÃ³n)
    - Inventario (pero bloqueado por nivel)
    
    ENV:
    - Pierde 3 niveles (mÃ­nimo 1)
  Criterio de Ã‰xito: "Constantes correctas"

TAREA-04.6.4:
  Nombre: "Implementar processor.ts para death"
  AcciÃ³n: "LÃ³gica de reset"
  Responsable: Antigravity
  Criterio de Ã‰xito: "Reset funciona correctamente"

TAREA-04.6.5:
    Nombre: "Implementar tests de death"
    AcciÃ³n: "Tests de reset completos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/death/death.test.ts:

      import { describe, it, expect } from 'vitest';
      import {
        processAvatarDeath,
        getLockedInventoryItems,
        generateDeathReport,
        canEquipItemAfterDeath
      } from './processor';
      import { DeathCause } from './types';

      describe('processAvatarDeath', () => {
        const mockStateBeforeDeath = {
          vectors: {
            aura_lvl: 5.50,
            face_lvl: 4.20,
            wealth_lvl: 6.00,
            muscle_lvl: 8.00,
            fat_lvl: 5.00,
            env_lvl: 7
          },
          health: { current: 0, max: 10, status: 'dead' },
          streak: 15,
          currentDay: 45,
          currentLevel: 5,
          btcBalance: 5000,
          inventory: [
            { id: '1', name: 'Rolex', level_required: 6 },
            { id: '2', name: 'Cadena bÃ¡sica', level_required: 2 }
          ]
        };

        it('resets physical vectors correctly', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);

          expect(result.newVectors.muscle_lvl).toBe(1.00);
          expect(result.newVectors.fat_lvl).toBe(13.00);
        });

        it('preserves mental/facial/wealth vectors', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);

          expect(result.newVectors.aura_lvl).toBe(5.50);
          expect(result.newVectors.face_lvl).toBe(4.20);
          expect(result.newVectors.wealth_lvl).toBe(6.00);
        });

        it('resets streak to 0', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);
          expect(result.newStreak).toBe(0);
        });

        it('resets day to 1', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);
          expect(result.newDay).toBe(1);
        });

        it('resets level to 1', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);
          expect(result.newLevel).toBe(1);
        });

        it('restores health to full', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);
          expect(result.newHealth.current).toBe(10);
          expect(result.newHealth.max).toBe(10);
          expect(result.newHealth.status).toBe('healthy');
        });

        it('preserves BTC balance', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);
          expect(result.btcRetained).toBe(5000);
        });

        it('penalizes env by 3 levels', () => {
          const result = processAvatarDeath(mockStateBeforeDeath, DeathCause.HEALTH_DEPLETED);
          expect(result.newVectors.env_lvl).toBe(4); // 7 - 3 = 4
        });

        it('env cannot go below 1', () => {
          const stateWithLowEnv = {
            ...mockStateBeforeDeath,
            vectors: { ...mockStateBeforeDeath.vectors, env_lvl: 2 }
          };
          const result = processAvatarDeath(stateWithLowEnv, DeathCause.HEALTH_DEPLETED);
          expect(result.newVectors.env_lvl).toBe(1); // 2 - 3 = -1, clamped to 1
        });
      });

      describe('getLockedInventoryItems', () => {
        const inventory = [
          { id: '1', name: 'Rolex', level_required: 6 },
          { id: '2', name: 'Cadena bÃ¡sica', level_required: 2 },
          { id: '3', name: 'Lentes', level_required: 1 }
        ];

        it('locks items above new level', () => {
          const locked = getLockedInventoryItems(inventory, 1);
          expect(locked).toHaveLength(2);
          expect(locked.map(i => i.id)).toEqual(['1', '2']);
        });

        it('does not lock items at or below new level', () => {
          const locked = getLockedInventoryItems(inventory, 6);
          expect(locked).toHaveLength(0);
        });
      });

      describe('generateDeathReport', () => {
        it('lists what was lost and kept', () => {
          const report = generateDeathReport(mockStateBeforeDeath, mockResurrectionResult);

          expect(report.whatWasLost).toContain('MÃºsculo: 8.00 â†’ 1.00');
          expect(report.whatWasLost).toContain('Racha: 15 dÃ­as');
          expect(report.whatWasLost).toContain('Progreso: DÃ­a 45 â†’ DÃ­a 1');

          expect(report.whatWasKept).toContain('AURA: 5.50');
          expect(report.whatWasKept).toContain('BTC: 5,000');
        });

        it('includes motivational message', () => {
          const report = generateDeathReport(mockStateBeforeDeath, mockResurrectionResult);
          expect(report.motivationalMessage.length).toBeGreaterThan(0);
        });
      });
    Criterio de Ã‰xito: "Todos los tests pasan"

  TAREA-04.6.6:
    Nombre: "Implementar index.ts para death"
    AcciÃ³n: "Exports pÃºblicos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/death/index.ts:

      // Types
      export type { DeathState, ResurrectionResult, DeathReport } from './types';
      export { DeathCause } from './types';

      // Constants
      export { DEATH_RESET_CONFIG, DEATH_MESSAGES } from './constants';

      // Processor
      export {
        processAvatarDeath,
        getLockedInventoryItems,
        generateDeathReport,
        canEquipItemAfterDeath
      } from './processor';
    Criterio de Ã‰xito: "Exports funcionan"

  TAREA-04.6.7:
    Nombre: "Ejecutar tests de death"
    AcciÃ³n: "Verificar suite completa"
    Responsable: Antigravity
    Comando: |
      npm run test src/lib/core/death/death.test.ts
    Criterio de Ã‰xito: "100% tests pasan"

  ---
  SUBCAJA 04.7: ECONOMÃA

  Sistema de BTC y Recompensas

  Archivos a Crear

  Ruta: /src/lib/core/economy/
  â”œâ”€â”€ index.ts              (Exports pÃºblicos)
  â”œâ”€â”€ types.ts              (Tipos econÃ³micos)
  â”œâ”€â”€ constants.ts          (Recompensas y lÃ­mites)
  â”œâ”€â”€ calculations.ts       (Funciones de cÃ¡lculo)
  â””â”€â”€ economy.test.ts       (Tests unitarios)

  TamaÃ±o Estimado: ~450 lÃ­neas total
  Tiempo de GeneraciÃ³n: 35-45 minutos

  Estructura del MÃ³dulo

  /src/lib/core/economy/
  â”‚
  â”œâ”€â”€ ğŸ“„ types.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ Currency (type): 'BTC'
  â”‚   â”‚   â””â”€â”€ Nota: Solo existe una moneda, BTC (sats internos)
  â”‚   â”‚
  â”‚   â”œâ”€â”€ TransactionType (enum)
  â”‚   â”‚   â”œâ”€â”€ TASK_REWARD = 'task_reward'
  â”‚   â”‚   â”œâ”€â”€ DAILY_BONUS = 'daily_bonus'
  â”‚   â”‚   â”œâ”€â”€ STREAK_MILESTONE = 'streak_milestone'
  â”‚   â”‚   â”œâ”€â”€ LEVEL_UP_BONUS = 'level_up_bonus'
  â”‚   â”‚   â”œâ”€â”€ PURCHASE = 'purchase'
  â”‚   â”‚   â””â”€â”€ REFUND = 'refund'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ Transaction (interface)
  â”‚   â”‚   â”œâ”€â”€ id: string
  â”‚   â”‚   â”œâ”€â”€ type: TransactionType
  â”‚   â”‚   â”œâ”€â”€ amount: number          // Positivo = ingreso, negativo = gasto
  â”‚   â”‚   â”œâ”€â”€ description: string
  â”‚   â”‚   â”œâ”€â”€ timestamp: Date
  â”‚   â”‚   â””â”€â”€ metadata?: Record<string, unknown>
  â”‚   â”‚
  â”‚   â”œâ”€â”€ EarningsBreakdown (interface)
  â”‚   â”‚   â”œâ”€â”€ taskRewards: number          // Suma de BTC por tareas
  â”‚   â”‚   â”œâ”€â”€ streakMultiplierBonus: number // Extra por multiplicador
  â”‚   â”‚   â”œâ”€â”€ dailyBonus: number           // Bonus por dÃ­a perfecto
  â”‚   â”‚   â”œâ”€â”€ levelUpBonus: number         // Bonus por subir nivel
  â”‚   â”‚   â”œâ”€â”€ streakMilestoneBonus: number // Bonus por milestone de racha
  â”‚   â”‚   â””â”€â”€ total: number
  â”‚   â”‚
  â”‚   â”œâ”€â”€ WalletState (interface)
  â”‚   â”‚   â”œâ”€â”€ balance: number
  â”‚   â”‚   â”œâ”€â”€ totalEarned: number
  â”‚   â”‚   â”œâ”€â”€ totalSpent: number
  â”‚   â”‚   â””â”€â”€ transactionCount: number
  â”‚   â”‚
  â”‚   â””â”€â”€ PurchaseResult (interface)
  â”‚       â”œâ”€â”€ success: boolean
  â”‚       â”œâ”€â”€ newBalance: number
  â”‚       â”œâ”€â”€ error?: string
  â”‚       â””â”€â”€ transaction?: Transaction
  â”‚
  â”œâ”€â”€ ğŸ“„ constants.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ BTC_REWARDS_BY_TASK (Recompensa base por tarea)
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // MENTAL
  â”‚   â”‚   â”œâ”€â”€ meditation: 15
  â”‚   â”‚   â”œâ”€â”€ cold_shower: 20
  â”‚   â”‚   â”œâ”€â”€ reading: 15
  â”‚   â”‚   â”œâ”€â”€ wake_early: 10
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // CARA
  â”‚   â”‚   â”œâ”€â”€ posture: 15
  â”‚   â”‚   â”œâ”€â”€ facial: 15
  â”‚   â”‚   â”œâ”€â”€ kegel: 10
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // PRODUCTIVIDAD
  â”‚   â”‚   â”œâ”€â”€ journal: 20
  â”‚   â”‚   â”œâ”€â”€ skill_learning: 25  // Por hora
  â”‚   â”‚   â”œâ”€â”€ focus_work: 20      // Por hora
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // FÃSICO
  â”‚   â”‚   â”œâ”€â”€ strength: 30
  â”‚   â”‚   â”œâ”€â”€ cardio: 25
  â”‚   â”‚   â””â”€â”€ hydration: 10
  â”‚   â”‚
  â”‚   â”œâ”€â”€ DAILY_BONUSES
  â”‚   â”‚   â”œâ”€â”€ PERFECT_DAY: 50          // 100% completado
  â”‚   â”‚   â”œâ”€â”€ ALMOST_PERFECT: 25       // 80-99% completado
  â”‚   â”‚   â””â”€â”€ FAILED_DAY: 0            // < 80%
  â”‚   â”‚
  â”‚   â”œâ”€â”€ LEVEL_UP_BONUSES
  â”‚   â”‚   â”œâ”€â”€ Formula: nivel * 100
  â”‚   â”‚   â”œâ”€â”€ Level 2: 200 BTC
  â”‚   â”‚   â”œâ”€â”€ Level 3: 300 BTC (AlucÃ­n, hito crÃ­tico)
  â”‚   â”‚   â”œâ”€â”€ Level 4: 400 BTC
  â”‚   â”‚   â”œâ”€â”€ Level 5: 500 BTC
  â”‚   â”‚   â”œâ”€â”€ Level 6: 600 BTC
  â”‚   â”‚   â”œâ”€â”€ Level 7: 700 BTC
  â”‚   â”‚   â”œâ”€â”€ Level 8: 800 BTC
  â”‚   â”‚   â”œâ”€â”€ Level 9: 900 BTC
  â”‚   â”‚   â””â”€â”€ Level 10: 1000 BTC (Semi-Dios)
  â”‚   â”‚
  â”‚   â”œâ”€â”€ STREAK_MILESTONE_BONUSES
  â”‚   â”‚   â”œâ”€â”€ 7 dÃ­as: 0 (solo recuperaciÃ³n de salud)
  â”‚   â”‚   â”œâ”€â”€ 14 dÃ­as: 500 BTC
  â”‚   â”‚   â”œâ”€â”€ 30 dÃ­as: 1,500 BTC
  â”‚   â”‚   â”œâ”€â”€ 60 dÃ­as: 3,000 BTC
  â”‚   â”‚   â””â”€â”€ 100 dÃ­as: 10,000 BTC
  â”‚   â”‚
  â”‚   â”œâ”€â”€ DAILY_EARNING_CAP: 1000 BTC
  â”‚   â”‚   â””â”€â”€ MÃ¡ximo que puedes ganar en un dÃ­a (sin milestones)
  â”‚   â”‚
  â”‚   â””â”€â”€ LEVEL_MULTIPLIERS (Multiplicador por nivel del usuario)
  â”‚       â”œâ”€â”€ Level 1-3: 1.0
  â”‚       â”œâ”€â”€ Level 4-5: 1.1
  â”‚       â”œâ”€â”€ Level 6-7: 1.2
  â”‚       â”œâ”€â”€ Level 8-9: 1.3
  â”‚       â””â”€â”€ Level 10+: 1.5
  â”‚
  â”œâ”€â”€ ğŸ“„ calculations.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getTaskReward(category: TaskCategory): number
  â”‚   â”‚   â””â”€â”€ Retorna BTC_REWARDS_BY_TASK[category]
  â”‚   â”‚
  â”‚   â”œâ”€â”€ calculateTaskRewardsTotal(
  â”‚   â”‚     completedTasks: TaskCategory[]
  â”‚   â”‚   ): number
  â”‚   â”‚   â””â”€â”€ Suma de todas las recompensas base de tareas
  â”‚   â”‚
  â”‚   â”œâ”€â”€ applyStreakMultiplier(
  â”‚   â”‚     baseReward: number,
  â”‚   â”‚     streakDays: number
  â”‚   â”‚   ): { total: number, bonus: number }
  â”‚   â”‚   â”œâ”€â”€ Calcula multiplicador de racha
  â”‚   â”‚   â”œâ”€â”€ total = baseReward * multiplier
  â”‚   â”‚   â””â”€â”€ bonus = total - baseReward
  â”‚   â”‚
  â”‚   â”œâ”€â”€ applyLevelMultiplier(
  â”‚   â”‚     baseReward: number,
  â”‚   â”‚     level: number
  â”‚   â”‚   ): { total: number, bonus: number }
  â”‚   â”‚   â””â”€â”€ Similar pero con multiplicador de nivel
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getDailyBonus(completionRate: number): number
  â”‚   â”‚   â”œâ”€â”€ 1.00 â†’ PERFECT_DAY (50)
  â”‚   â”‚   â”œâ”€â”€ 0.80-0.99 â†’ ALMOST_PERFECT (25)
  â”‚   â”‚   â””â”€â”€ < 0.80 â†’ 0
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getLevelUpBonus(newLevel: number): number
  â”‚   â”‚   â””â”€â”€ newLevel * 100
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getStreakMilestoneBonus(
  â”‚   â”‚     previousStreak: number,
  â”‚   â”‚     newStreak: number
  â”‚   â”‚   ): number
  â”‚   â”‚   â””â”€â”€ Si cruzÃ³ milestone, retorna el bonus correspondiente
  â”‚   â”‚
  â”‚   â”œâ”€â”€ calculateDayEarnings(params: {
  â”‚   â”‚     completedTasks: TaskCategory[],
  â”‚   â”‚     completionRate: number,
  â”‚   â”‚     streakDays: number,
  â”‚   â”‚     userLevel: number,
  â”‚   â”‚     leveledUp: boolean,
  â”‚   â”‚     streakMilestoneReached: number | null
  â”‚   â”‚   }): EarningsBreakdown
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ PASO 1: Calcular recompensas base por tareas
  â”‚   â”‚   â”œâ”€â”€ PASO 2: Aplicar multiplicador de racha
  â”‚   â”‚   â”œâ”€â”€ PASO 3: Aplicar multiplicador de nivel
  â”‚   â”‚   â”œâ”€â”€ PASO 4: Agregar bonus diario
  â”‚   â”‚   â”œâ”€â”€ PASO 5: Agregar bonus de level up si aplica
  â”‚   â”‚   â”œâ”€â”€ PASO 6: Agregar bonus de milestone de racha si aplica
  â”‚   â”‚   â”œâ”€â”€ PASO 7: Aplicar cap diario (excepto milestones)
  â”‚   â”‚   â””â”€â”€ PASO 8: Retornar breakdown completo
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canAffordPurchase(
  â”‚   â”‚     balance: number,
  â”‚   â”‚     price: number
  â”‚   â”‚   ): boolean
  â”‚   â”‚   â””â”€â”€ balance >= price
  â”‚   â”‚
  â”‚   â”œâ”€â”€ processPurchase(
  â”‚   â”‚     wallet: WalletState,
  â”‚   â”‚     price: number,
  â”‚   â”‚     itemName: string
  â”‚   â”‚   ): PurchaseResult
  â”‚   â”‚   â”œâ”€â”€ Verifica balance suficiente
  â”‚   â”‚   â”œâ”€â”€ Resta precio del balance
  â”‚   â”‚   â””â”€â”€ Crea transacciÃ³n
  â”‚   â”‚
  â”‚   â””â”€â”€ formatBtcAmount(amount: number): string
  â”‚       â””â”€â”€ Formato: "1,500 BTC" con separadores de miles
  â”‚
  â””â”€â”€ ğŸ“„ economy.test.ts
      â”‚
      â”œâ”€â”€ describe('getTaskReward')
      â”‚   â”œâ”€â”€ it('returns 15 for meditation')
      â”‚   â”œâ”€â”€ it('returns 30 for strength')
      â”‚   â””â”€â”€ it('returns 0 for unknown task')
      â”‚
      â”œâ”€â”€ describe('calculateTaskRewardsTotal')
      â”‚   â”œâ”€â”€ it('sums multiple task rewards')
      â”‚   â””â”€â”€ it('returns 0 for empty array')
      â”‚
      â”œâ”€â”€ describe('applyStreakMultiplier')
      â”‚   â”œâ”€â”€ it('returns 1.0x for streak 0-6')
      â”‚   â”œâ”€â”€ it('returns 1.1x for streak 7-13')
      â”‚   â”œâ”€â”€ it('returns 2.0x for streak 90+')
      â”‚   â””â”€â”€ it('calculates bonus correctly')
      â”‚
      â”œâ”€â”€ describe('getDailyBonus')
      â”‚   â”œâ”€â”€ it('returns 50 for 100% completion')
      â”‚   â”œâ”€â”€ it('returns 25 for 80-99% completion')
      â”‚   â””â”€â”€ it('returns 0 for < 80%')
      â”‚
      â”œâ”€â”€ describe('calculateDayEarnings')
      â”‚   â”œâ”€â”€ it('calculates perfect day correctly')
      â”‚   â”‚   Input: 5 tareas completadas, 100%, streak 10, level 3
      â”‚   â”‚   Expected: tasks + streak bonus + daily bonus
      â”‚   â”‚
      â”‚   â”œâ”€â”€ it('applies level multiplier correctly')
      â”‚   â”œâ”€â”€ it('includes level up bonus when applicable')
      â”‚   â”œâ”€â”€ it('includes streak milestone bonus when reached')
      â”‚   â”œâ”€â”€ it('respects daily cap')
      â”‚   â””â”€â”€ it('excludes milestones from cap')
      â”‚
      â”œâ”€â”€ describe('processPurchase')
      â”‚   â”œâ”€â”€ it('succeeds when balance sufficient')
      â”‚   â”œâ”€â”€ it('fails when balance insufficient')
      â”‚   â””â”€â”€ it('updates wallet state correctly')
      â”‚
      â””â”€â”€ describe('formatBtcAmount')
          â”œâ”€â”€ it('formats 1500 as "1,500 BTC"')
          â””â”€â”€ it('formats 1000000 as "1,000,000 BTC"')

  Tareas AtÃ³micas para 04.7 EconomÃ­a

  TAREA-04.7.1:
    Nombre: "Crear estructura para economy"
    AcciÃ³n: "Crear carpeta y archivos"
    Responsable: Antigravity
    Comando: |
      mkdir -p src/lib/core/economy
      touch src/lib/core/economy/{index,types,constants,calculations}.ts
      touch src/lib/core/economy/economy.test.ts
    Criterio de Ã‰xito: "Archivos existen"

  TAREA-04.7.2:
    Nombre: "Implementar types.ts para economy"
    AcciÃ³n: "Definir tipos econÃ³micos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/economy/types.ts:

      1. type Currency = 'BTC'

      2. enum TransactionType {
           TASK_REWARD = 'task_reward',
           DAILY_BONUS = 'daily_bonus',
           STREAK_MILESTONE = 'streak_milestone',
           LEVEL_UP_BONUS = 'level_up_bonus',
           PURCHASE = 'purchase',
           REFUND = 'refund'
         }

      3. interface Transaction {
           id: string;
           type: TransactionType;
           amount: number;
           description: string;
           timestamp: Date;
           metadata?: Record<string, unknown>;
         }

      4. interface EarningsBreakdown {
           taskRewards: number;
           streakMultiplierBonus: number;
           dailyBonus: number;
           levelUpBonus: number;
           streakMilestoneBonus: number;
           total: number;
         }

      5. interface WalletState {
           balance: number;
           totalEarned: number;
           totalSpent: number;
           transactionCount: number;
         }

      6. interface PurchaseResult {
           success: boolean;
           newBalance: number;
           error?: string;
           transaction?: Transaction;
         }

      Documenta con JSDoc.
    Criterio de Ã‰xito: "Tipos compilan sin errores"

  TAREA-04.7.3:
    Nombre: "Implementar constants.ts para economy"
    AcciÃ³n: "Definir recompensas y lÃ­mites"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/economy/constants.ts:

      import { TaskCategory } from '../vectors/types';

      export const BTC_REWARDS_BY_TASK: Record<TaskCategory, number> = {
        // MENTAL
        meditation: 15,
        cold_shower: 20,
        reading: 15,
        wake_early: 10,

        // CARA
        posture: 15,
        facial: 15,
        kegel: 10,

        // PRODUCTIVIDAD
        journal: 20,
        skill_learning: 25,
        focus_work: 20,

        // FÃSICO
        strength: 30,
        cardio: 25,
        hydration: 10
      } as const;

      export const DAILY_BONUSES = {
        PERFECT_DAY: 50,      // 100% completado
        ALMOST_PERFECT: 25,   // 80-99% completado
        FAILED_DAY: 0         // < 80%
      } as const;

      export const LEVEL_UP_BONUS_MULTIPLIER = 100;
      // Level 3 = 300 BTC, Level 10 = 1000 BTC

      export const STREAK_MILESTONE_BONUSES: Record<number, number> = {
        7: 0,        // Solo recuperaciÃ³n de salud
        14: 500,
        30: 1500,
        60: 3000,
        100: 10000
      } as const;

      export const DAILY_EARNING_CAP = 1000;

      export const LEVEL_MULTIPLIERS: Record<number, number> = {
        1: 1.0, 2: 1.0, 3: 1.0,
        4: 1.1, 5: 1.1,
        6: 1.2, 7: 1.2,
        8: 1.3, 9: 1.3,
        10: 1.5, 11: 1.5, 12: 1.5, 13: 1.5
      } as const;

      export const INITIAL_WALLET_STATE: WalletState = {
        balance: 0,
        totalEarned: 0,
        totalSpent: 0,
        transactionCount: 0
      };
    Criterio de Ã‰xito: "Constantes exportan correctamente"

  TAREA-04.7.4:
    Nombre: "Implementar calculations.ts - Funciones bÃ¡sicas"
    AcciÃ³n: "getTaskReward, calculateTaskRewardsTotal"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/economy/calculations.ts:

      import { TaskCategory } from '../vectors/types';
      import { BTC_REWARDS_BY_TASK, DAILY_BONUSES, LEVEL_MULTIPLIERS } from './constants';
      import { calculateStreakMultiplier } from '../streak/calculations';

      export function getTaskReward(category: TaskCategory): number {
        return BTC_REWARDS_BY_TASK[category] ?? 0;
      }

      export function calculateTaskRewardsTotal(completedTasks: TaskCategory[]): number {
        return completedTasks.reduce((sum, task) => sum + getTaskReward(task), 0);
      }

      export function applyStreakMultiplier(
        baseReward: number,
        streakDays: number
      ): { total: number; bonus: number } {
        const multiplier = calculateStreakMultiplier(streakDays);
        const total = Math.round(baseReward * multiplier);
        const bonus = total - baseReward;
        return { total, bonus };
      }

      export function applyLevelMultiplier(
        baseReward: number,
        level: number
      ): { total: number; bonus: number } {
        const multiplier = LEVEL_MULTIPLIERS[level] ?? 1.0;
        const total = Math.round(baseReward * multiplier);
        const bonus = total - baseReward;
        return { total, bonus };
      }

      export function getDailyBonus(completionRate: number): number {
        if (completionRate >= 1.0) return DAILY_BONUSES.PERFECT_DAY;
        if (completionRate >= 0.8) return DAILY_BONUSES.ALMOST_PERFECT;
        return DAILY_BONUSES.FAILED_DAY;
      }
    Criterio de Ã‰xito: "Funciones bÃ¡sicas funcionan"

  TAREA-04.7.5:
    Nombre: "Implementar calculations.ts - calculateDayEarnings"
    AcciÃ³n: "FunciÃ³n principal de economÃ­a diaria"
    Responsable: Antigravity
    Prompt para Antigravity: |
      ContinÃºa en /src/lib/core/economy/calculations.ts:

      import {
        LEVEL_UP_BONUS_MULTIPLIER,
        STREAK_MILESTONE_BONUSES,
        DAILY_EARNING_CAP
      } from './constants';

      export function getLevelUpBonus(newLevel: number): number {
        return newLevel * LEVEL_UP_BONUS_MULTIPLIER;
      }

      export function getStreakMilestoneBonus(
        previousStreak: number,
        newStreak: number
      ): number {
        const milestones = Object.keys(STREAK_MILESTONE_BONUSES)
          .map(Number)
          .sort((a, b) => a - b);

        for (const milestone of milestones) {
          if (previousStreak < milestone && newStreak >= milestone) {
            return STREAK_MILESTONE_BONUSES[milestone];
          }
        }
        return 0;
      }

      interface DayEarningsParams {
        completedTasks: TaskCategory[];
        completionRate: number;
        streakDays: number;
        userLevel: number;
        leveledUp: boolean;
        newLevel?: number;
        previousStreak: number;
      }

      export function calculateDayEarnings(params: DayEarningsParams): EarningsBreakdown {
        const {
          completedTasks,
          completionRate,
          streakDays,
          userLevel,
          leveledUp,
          newLevel,
          previousStreak
        } = params;

        // PASO 1: Recompensas base por tareas
        const taskRewardsBase = calculateTaskRewardsTotal(completedTasks);

        // PASO 2: Aplicar multiplicador de racha
        const streakResult = applyStreakMultiplier(taskRewardsBase, streakDays);

        // PASO 3: Aplicar multiplicador de nivel
        const levelResult = applyLevelMultiplier(streakResult.total, userLevel);

        // PASO 4: Bonus diario
        const dailyBonus = getDailyBonus(completionRate);

        // PASO 5: Bonus level up
        const levelUpBonus = leveledUp && newLevel ? getLevelUpBonus(newLevel) : 0;

        // PASO 6: Bonus milestone racha
        const streakMilestoneBonus = getStreakMilestoneBonus(previousStreak, streakDays);

        // Calcular subtotal sin milestones (para cap)
        const regularEarnings = levelResult.total + dailyBonus;
        const cappedRegularEarnings = Math.min(regularEarnings, DAILY_EARNING_CAP);

        // Total: capped regular + milestones (sin cap)
        const total = cappedRegularEarnings + levelUpBonus + streakMilestoneBonus;

        return {
          taskRewards: taskRewardsBase,
          streakMultiplierBonus: streakResult.bonus + levelResult.bonus,
          dailyBonus,
          levelUpBonus,
          streakMilestoneBonus,
          total
        };
      }
    Criterio de Ã‰xito: "CÃ¡lculo de ganancias funciona"

  TAREA-04.7.6:
    Nombre: "Implementar calculations.ts - processPurchase"
    AcciÃ³n: "Funciones de compra"
    Responsable: Antigravity
    Prompt para Antigravity: |
      ContinÃºa en /src/lib/core/economy/calculations.ts:

      export function canAffordPurchase(balance: number, price: number): boolean {
        return balance >= price;
      }

      export function processPurchase(
        wallet: WalletState,
        price: number,
        itemName: string
      ): PurchaseResult {
        if (!canAffordPurchase(wallet.balance, price)) {
          return {
            success: false,
            newBalance: wallet.balance,
            error: `Saldo insuficiente. Necesitas ${formatBtcAmount(price)} pero tienes ${formatBtcAmount(wallet.balance)}`
          };
        }

        const newBalance = wallet.balance - price;
        const transaction: Transaction = {
          id: generateTransactionId(),
          type: TransactionType.PURCHASE,
          amount: -price,
          description: `Compra: ${itemName}`,
          timestamp: new Date()
        };

        return {
          success: true,
          newBalance,
          transaction
        };
      }

      export function formatBtcAmount(amount: number): string {
        return amount.toLocaleString('es-MX') + ' BTC';
      }

      function generateTransactionId(): string {
        return `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }

      export function createEarningsTransaction(
        breakdown: EarningsBreakdown,
        day: number
      ): Transaction {
        return {
          id: generateTransactionId(),
          type: TransactionType.TASK_REWARD,
          amount: breakdown.total,
          description: `Ganancias del DÃ­a ${day}`,
          timestamp: new Date(),
          metadata: breakdown
        };
      }
    Criterio de Ã‰xito: "Sistema de compras funciona"

  TAREA-04.7.7:
    Nombre: "Implementar index.ts para economy"
    AcciÃ³n: "Exports pÃºblicos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/economy/index.ts:

      // Types
      export type {
        Transaction,
        EarningsBreakdown,
        WalletState,
        PurchaseResult
      } from './types';
      export { TransactionType } from './types';

      // Constants
      export {
        BTC_REWARDS_BY_TASK,
        DAILY_BONUSES,
        LEVEL_UP_BONUS_MULTIPLIER,
        STREAK_MILESTONE_BONUSES,
        DAILY_EARNING_CAP,
        LEVEL_MULTIPLIERS,
        INITIAL_WALLET_STATE
      } from './constants';

      // Calculations
      export {
        getTaskReward,
        calculateTaskRewardsTotal,
        applyStreakMultiplier,
        applyLevelMultiplier,
        getDailyBonus,
        getLevelUpBonus,
        getStreakMilestoneBonus,
        calculateDayEarnings,
        canAffordPurchase,
        processPurchase,
        formatBtcAmount,
        createEarningsTransaction
      } from './calculations';
    Criterio de Ã‰xito: "Exports funcionan"

  TAREA-04.7.8:
    Nombre: "Implementar tests de economy"
    AcciÃ³n: "Suite completa de tests"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/economy/economy.test.ts:

      import { describe, it, expect } from 'vitest';
      import {
        getTaskReward,
        calculateTaskRewardsTotal,
        applyStreakMultiplier,
        getDailyBonus,
        getLevelUpBonus,
        getStreakMilestoneBonus,
        calculateDayEarnings,
        canAffordPurchase,
        processPurchase,
        formatBtcAmount
      } from './calculations';
      import { TaskCategory } from '../vectors/types';

      describe('getTaskReward', () => {
        it('returns 15 for meditation', () => {
          expect(getTaskReward(TaskCategory.MEDITATION)).toBe(15);
        });

        it('returns 30 for strength', () => {
          expect(getTaskReward(TaskCategory.STRENGTH)).toBe(30);
        });

        it('returns 25 for cardio', () => {
          expect(getTaskReward(TaskCategory.CARDIO)).toBe(25);
        });
      });

      describe('calculateTaskRewardsTotal', () => {
        it('sums multiple task rewards correctly', () => {
          const tasks = [
            TaskCategory.MEDITATION, // 15
            TaskCategory.STRENGTH,   // 30
            TaskCategory.CARDIO      // 25
          ];
          expect(calculateTaskRewardsTotal(tasks)).toBe(70);
        });

        it('returns 0 for empty array', () => {
          expect(calculateTaskRewardsTotal([])).toBe(0);
        });
      });

      describe('applyStreakMultiplier', () => {
        it('returns 1.0x for streak 0-6', () => {
          const result = applyStreakMultiplier(100, 5);
          expect(result.total).toBe(100);
          expect(result.bonus).toBe(0);
        });

        it('returns 1.1x for streak 7-13', () => {
          const result = applyStreakMultiplier(100, 10);
          expect(result.total).toBe(110);
          expect(result.bonus).toBe(10);
        });

        it('returns 2.0x for streak 90+', () => {
          const result = applyStreakMultiplier(100, 95);
          expect(result.total).toBe(200);
          expect(result.bonus).toBe(100);
        });
      });

      describe('getDailyBonus', () => {
        it('returns 50 for 100% completion', () => {
          expect(getDailyBonus(1.0)).toBe(50);
        });

        it('returns 25 for 80% completion', () => {
          expect(getDailyBonus(0.8)).toBe(25);
        });

        it('returns 25 for 95% completion', () => {
          expect(getDailyBonus(0.95)).toBe(25);
        });

        it('returns 0 for 79% completion', () => {
          expect(getDailyBonus(0.79)).toBe(0);
        });
      });

      describe('getLevelUpBonus', () => {
        it('returns 300 for level 3 (AlucÃ­n)', () => {
          expect(getLevelUpBonus(3)).toBe(300);
        });

        it('returns 1000 for level 10 (Semi-Dios)', () => {
          expect(getLevelUpBonus(10)).toBe(1000);
        });
      });

      describe('getStreakMilestoneBonus', () => {
        it('returns 500 when crossing 14 days', () => {
          expect(getStreakMilestoneBonus(13, 14)).toBe(500);
        });

        it('returns 1500 when crossing 30 days', () => {
          expect(getStreakMilestoneBonus(29, 30)).toBe(1500);
        });

        it('returns 0 when not crossing milestone', () => {
          expect(getStreakMilestoneBonus(8, 9)).toBe(0);
        });

        it('returns 10000 when crossing 100 days', () => {
          expect(getStreakMilestoneBonus(99, 100)).toBe(10000);
        });
      });

      describe('calculateDayEarnings', () => {
        it('calculates perfect day correctly', () => {
          const result = calculateDayEarnings({
            completedTasks: [
              TaskCategory.MEDITATION, // 15
              TaskCategory.STRENGTH,   // 30
              TaskCategory.CARDIO,     // 25
              TaskCategory.JOURNAL     // 20
            ],
            completionRate: 1.0,
            streakDays: 10,  // 1.1x
            userLevel: 3,    // 1.0x
            leveledUp: false,
            previousStreak: 9
          });

          // Base: 90
          // Streak 1.1x: 99, bonus: 9
          // Level 1.0x: 99, bonus: 0
          // Daily bonus: 50
          // Total regular: 149 (bajo cap de 1000)
          expect(result.taskRewards).toBe(90);
          expect(result.dailyBonus).toBe(50);
          expect(result.total).toBeGreaterThan(130);
        });

        it('respects daily cap', () => {
          // Crear escenario con muchas tareas para exceder cap
          const manyTasks = Array(20).fill(TaskCategory.STRENGTH); // 20 * 30 = 600

          const result = calculateDayEarnings({
            completedTasks: manyTasks,
            completionRate: 1.0,
            streakDays: 95,  // 2.0x
            userLevel: 10,   // 1.5x
            leveledUp: false,
            previousStreak: 94
          });

          // Base: 600
          // Streak 2.0x: 1200
          // Level 1.5x: 1800
          // Daily: 50
          // Should be capped at 1000 + daily bonus
          expect(result.total).toBeLessThanOrEqual(1050);
        });

        it('includes level up bonus when applicable', () => {
          const result = calculateDayEarnings({
            completedTasks: [TaskCategory.MEDITATION],
            completionRate: 1.0,
            streakDays: 5,
            userLevel: 3,
            leveledUp: true,
            newLevel: 3,
            previousStreak: 4
          });

          expect(result.levelUpBonus).toBe(300);
        });
      });

      describe('processPurchase', () => {
        const wallet: WalletState = {
          balance: 1000,
          totalEarned: 1000,
          totalSpent: 0,
          transactionCount: 0
        };

        it('succeeds when balance sufficient', () => {
          const result = processPurchase(wallet, 500, 'Cadena de oro');

          expect(result.success).toBe(true);
          expect(result.newBalance).toBe(500);
          expect(result.transaction).toBeDefined();
          expect(result.transaction?.amount).toBe(-500);
        });

        it('fails when balance insufficient', () => {
          const result = processPurchase(wallet, 1500, 'Rolex');

          expect(result.success).toBe(false);
          expect(result.newBalance).toBe(1000);
          expect(result.error).toContain('insuficiente');
        });
      });

      describe('formatBtcAmount', () => {
        it('formats 1500 correctly', () => {
          expect(formatBtcAmount(1500)).toBe('1,500 BTC');
        });

        it('formats 1000000 correctly', () => {
          expect(formatBtcAmount(1000000)).toBe('1,000,000 BTC');
        });
      });
    Criterio de Ã‰xito: "Todos los tests pasan"

  TAREA-04.7.9:
    Nombre: "Ejecutar tests de economy"
    AcciÃ³n: "Verificar suite completa"
    Responsable: Antigravity
    Comando: |
      npm run test src/lib/core/economy/economy.test.ts
    Criterio de Ã‰xito: "100% tests pasan"

  ---
  SUBCAJA 04.8: PROTOCOLO DE 100 DÃAS

  Estructura Temporal del Sistema

  Archivos a Crear

  Ruta: /src/lib/core/protocol/
  â”œâ”€â”€ index.ts              (Exports pÃºblicos)
  â”œâ”€â”€ types.ts              (Tipos del protocolo)
  â”œâ”€â”€ constants.ts          (Fases y configuraciÃ³n)
  â”œâ”€â”€ day-structure.ts      (Estructura de tareas por dÃ­a)
  â”œâ”€â”€ milestones.ts         (Hitos especiales)
  â””â”€â”€ protocol.test.ts      (Tests unitarios)

  TamaÃ±o Estimado: ~650 lÃ­neas total
  Tiempo de GeneraciÃ³n: 50-65 minutos

  Estructura del MÃ³dulo

  /src/lib/core/protocol/
  â”‚
  â”œâ”€â”€ ğŸ“„ types.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ ProtocolPhase (enum)
  â”‚   â”‚   â”œâ”€â”€ TRIAL = 'trial'           // DÃ­as 1-5
  â”‚   â”‚   â”œâ”€â”€ FOUNDATION = 'foundation' // DÃ­as 6-30
  â”‚   â”‚   â”œâ”€â”€ BUILDING = 'building'     // DÃ­as 31-60
  â”‚   â”‚   â”œâ”€â”€ MASTERY = 'mastery'       // DÃ­as 61-100
  â”‚   â”‚   â””â”€â”€ POST_GAME = 'post_game'   // DÃ­a 101+
  â”‚   â”‚
  â”‚   â”œâ”€â”€ PhaseInfo (interface)
  â”‚   â”‚   â”œâ”€â”€ phase: ProtocolPhase
  â”‚   â”‚   â”œâ”€â”€ name: string
  â”‚   â”‚   â”œâ”€â”€ startDay: number
  â”‚   â”‚   â”œâ”€â”€ endDay: number
  â”‚   â”‚   â”œâ”€â”€ description: string
  â”‚   â”‚   â”œâ”€â”€ difficultyMultiplier: number
  â”‚   â”‚   â”œâ”€â”€ tasksPerDay: number
  â”‚   â”‚   â””â”€â”€ unlockedFeatures: string[]
  â”‚   â”‚
  â”‚   â”œâ”€â”€ DayConfig (interface)
  â”‚   â”‚   â”œâ”€â”€ dayNumber: number
  â”‚   â”‚   â”œâ”€â”€ phase: ProtocolPhase
  â”‚   â”‚   â”œâ”€â”€ requiredTasks: TaskCategory[]
  â”‚   â”‚   â”œâ”€â”€ optionalTasks: TaskCategory[]
  â”‚   â”‚   â”œâ”€â”€ specialEvent?: SpecialEvent
  â”‚   â”‚   â””â”€â”€ isPaywallDay: boolean
  â”‚   â”‚
  â”‚   â”œâ”€â”€ SpecialEvent (interface)
  â”‚   â”‚   â”œâ”€â”€ type: 'milestone' | 'challenge' | 'bonus'
  â”‚   â”‚   â”œâ”€â”€ name: string
  â”‚   â”‚   â”œâ”€â”€ description: string
  â”‚   â”‚   â””â”€â”€ rewards: EventReward[]
  â”‚   â”‚
  â”‚   â””â”€â”€ EventReward (interface)
  â”‚       â”œâ”€â”€ type: 'btc' | 'item' | 'badge' | 'health'
  â”‚       â”œâ”€â”€ amount?: number
  â”‚       â””â”€â”€ itemId?: string
  â”‚
  â”œâ”€â”€ ğŸ“„ constants.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ PROTOCOL_CONFIG
  â”‚   â”‚   â”œâ”€â”€ TOTAL_DAYS: 100
  â”‚   â”‚   â”œâ”€â”€ TRIAL_DAYS: 5
  â”‚   â”‚   â”œâ”€â”€ PAYWALL_DAY: 6
  â”‚   â”‚   â””â”€â”€ POST_GAME_START: 101
  â”‚   â”‚
  â”‚   â”œâ”€â”€ PHASES: Record<ProtocolPhase, PhaseInfo>
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ TRIAL (DÃ­as 1-5)
  â”‚   â”‚   â”‚   â”œâ”€â”€ name: "Prueba Gratuita"
  â”‚   â”‚   â”‚   â”œâ”€â”€ difficultyMultiplier: 0.6
  â”‚   â”‚   â”‚   â”œâ”€â”€ tasksPerDay: 3
  â”‚   â”‚   â”‚   â””â”€â”€ unlockedFeatures: ['basic_tasks', 'avatar_preview']
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ FOUNDATION (DÃ­as 6-30)
  â”‚   â”‚   â”‚   â”œâ”€â”€ name: "FundaciÃ³n"
  â”‚   â”‚   â”‚   â”œâ”€â”€ difficultyMultiplier: 0.8
  â”‚   â”‚   â”‚   â”œâ”€â”€ tasksPerDay: 4
  â”‚   â”‚   â”‚   â””â”€â”€ unlockedFeatures: ['full_tasks', 'store_basic', 'avatar_full']
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ BUILDING (DÃ­as 31-60)
  â”‚   â”‚   â”‚   â”œâ”€â”€ name: "ConstrucciÃ³n"
  â”‚   â”‚   â”‚   â”œâ”€â”€ difficultyMultiplier: 1.0
  â”‚   â”‚   â”‚   â”œâ”€â”€ tasksPerDay: 5
  â”‚   â”‚   â”‚   â””â”€â”€ unlockedFeatures: ['store_premium', 'advanced_stats']
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ MASTERY (DÃ­as 61-100)
  â”‚   â”‚   â”‚   â”œâ”€â”€ name: "MaestrÃ­a"
  â”‚   â”‚   â”‚   â”œâ”€â”€ difficultyMultiplier: 1.2
  â”‚   â”‚   â”‚   â”œâ”€â”€ tasksPerDay: 6
  â”‚   â”‚   â”‚   â””â”€â”€ unlockedFeatures: ['elite_store', 'full_customization']
  â”‚   â”‚   â”‚
  â”‚   â”‚   â””â”€â”€ POST_GAME (DÃ­a 101+)
  â”‚   â”‚       â”œâ”€â”€ name: "Post-Game"
  â”‚   â”‚       â”œâ”€â”€ difficultyMultiplier: 1.5
  â”‚   â”‚       â”œâ”€â”€ tasksPerDay: 6
  â”‚   â”‚       â””â”€â”€ unlockedFeatures: ['infinite_mode', 'leaderboards']
  â”‚   â”‚
  â”‚   â”œâ”€â”€ TASKS_BY_ARCHETYPE
  â”‚   â”‚   â”œâ”€â”€ MENTAL: [meditation, cold_shower, reading, wake_early]
  â”‚   â”‚   â”œâ”€â”€ CARA: [posture, facial, kegel]
  â”‚   â”‚   â”œâ”€â”€ PRODUCTIVIDAD: [journal, skill_learning, focus_work]
  â”‚   â”‚   â””â”€â”€ FISICO: [strength, cardio, hydration]
  â”‚   â”‚
  â”‚   â””â”€â”€ SPECIAL_DAYS: Record<number, SpecialEvent>
  â”‚       â”œâ”€â”€ 6: "DÃ­a de ConversiÃ³n" (Paywall)
  â”‚       â”œâ”€â”€ 30: "Primer Mes" (Badge + 1500 BTC)
  â”‚       â”œâ”€â”€ 60: "Medio Camino" (Badge + 3000 BTC)
  â”‚       â””â”€â”€ 100: "Victoria Final" (Badge Ã©pico + 10000 BTC)
  â”‚
  â”œâ”€â”€ ğŸ“„ day-structure.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getCurrentPhase(dayNumber: number): ProtocolPhase
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getPhaseInfo(phase: ProtocolPhase): PhaseInfo
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getDayConfig(dayNumber: number): DayConfig
  â”‚   â”‚   â”œâ”€â”€ Determina fase
  â”‚   â”‚   â”œâ”€â”€ Genera tareas requeridas segÃºn fase
  â”‚   â”‚   â”œâ”€â”€ Genera tareas opcionales
  â”‚   â”‚   â””â”€â”€ Agrega evento especial si aplica
  â”‚   â”‚
  â”‚   â”œâ”€â”€ generateDailyTasks(
  â”‚   â”‚     dayNumber: number,
  â”‚   â”‚     userPreferences?: TaskPreferences
  â”‚   â”‚   ): { required: TaskCategory[], optional: TaskCategory[] }
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ TRIAL (3 tareas)
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 Mental
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 FÃ­sico
  â”‚   â”‚   â”‚   â””â”€â”€ 1 Opcional (cualquier arquetipo)
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ FOUNDATION (4 tareas)
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 Mental
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 Cara
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 FÃ­sico
  â”‚   â”‚   â”‚   â””â”€â”€ 1 Productividad
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ BUILDING (5 tareas)
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 Mental
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 Cara
  â”‚   â”‚   â”‚   â”œâ”€â”€ 1 Productividad
  â”‚   â”‚   â”‚   â””â”€â”€ 2 FÃ­sico
  â”‚   â”‚   â”‚
  â”‚   â”‚   â””â”€â”€ MASTERY (6 tareas)
  â”‚   â”‚       â”œâ”€â”€ 2 Mental
  â”‚   â”‚       â”œâ”€â”€ 1 Cara
  â”‚   â”‚       â”œâ”€â”€ 1 Productividad
  â”‚   â”‚       â””â”€â”€ 2 FÃ­sico
  â”‚   â”‚
  â”‚   â”œâ”€â”€ isPaywallDay(dayNumber: number): boolean
  â”‚   â”‚   â””â”€â”€ dayNumber === PROTOCOL_CONFIG.PAYWALL_DAY
  â”‚   â”‚
  â”‚   â”œâ”€â”€ isTrialExpired(dayNumber: number): boolean
  â”‚   â”‚   â””â”€â”€ dayNumber > PROTOCOL_CONFIG.TRIAL_DAYS
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getProgressPercentage(dayNumber: number): number
  â”‚   â”‚   â””â”€â”€ Math.min(100, (dayNumber / 100) * 100)
  â”‚   â”‚
  â”‚   â””â”€â”€ getDaysRemaining(dayNumber: number): number
  â”‚       â””â”€â”€ Math.max(0, 100 - dayNumber)
  â”‚
  â”œâ”€â”€ ğŸ“„ milestones.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getSpecialEvent(dayNumber: number): SpecialEvent | null
  â”‚   â”‚
  â”‚   â”œâ”€â”€ isMilestoneDay(dayNumber: number): boolean
  â”‚   â”‚
  â”‚   â”œâ”€â”€ getMilestoneRewards(dayNumber: number): EventReward[]
  â”‚   â”‚
  â”‚   â”œâ”€â”€ MILESTONE_MESSAGES: Record<number, string>
  â”‚   â”‚   â”œâ”€â”€ 6: "Â¡Bienvenido al sistema completo! Tu viaje de 100 dÃ­as comienza ahora."
  â”‚   â”‚   â”œâ”€â”€ 30: "Â¡Primer mes completado! Has demostrado consistencia."
  â”‚   â”‚   â”œâ”€â”€ 60: "Â¡Medio camino! Tu disciplina es inquebrantable."
  â”‚   â”‚   â””â”€â”€ 100: "Â¡VICTORIA! Has completado el protocolo METAMEN100."
  â”‚   â”‚
  â”‚   â””â”€â”€ generateMilestoneReport(
  â”‚       dayNumber: number,
  â”‚       stats: UserStats
  â”‚     ): MilestoneReport
  â”‚
  â””â”€â”€ ğŸ“„ protocol.test.ts
      â”‚
      â”œâ”€â”€ describe('getCurrentPhase')
      â”‚   â”œâ”€â”€ it('returns TRIAL for days 1-5')
      â”‚   â”œâ”€â”€ it('returns FOUNDATION for days 6-30')
      â”‚   â”œâ”€â”€ it('returns BUILDING for days 31-60')
      â”‚   â”œâ”€â”€ it('returns MASTERY for days 61-100')
      â”‚   â””â”€â”€ it('returns POST_GAME for days 101+')
      â”‚
      â”œâ”€â”€ describe('generateDailyTasks')
      â”‚   â”œâ”€â”€ it('generates 3 tasks for TRIAL phase')
      â”‚   â”œâ”€â”€ it('generates 4 tasks for FOUNDATION phase')
      â”‚   â”œâ”€â”€ it('generates 5 tasks for BUILDING phase')
      â”‚   â”œâ”€â”€ it('generates 6 tasks for MASTERY phase')
      â”‚   â””â”€â”€ it('includes all archetypes appropriately')
      â”‚
      â”œâ”€â”€ describe('isPaywallDay')
      â”‚   â”œâ”€â”€ it('returns true for day 6')
      â”‚   â””â”€â”€ it('returns false for other days')
      â”‚
      â”œâ”€â”€ describe('isTrialExpired')
      â”‚   â”œâ”€â”€ it('returns false for days 1-5')
      â”‚   â””â”€â”€ it('returns true for day 6+')
      â”‚
      â””â”€â”€ describe('isMilestoneDay')
          â”œâ”€â”€ it('returns true for day 6, 30, 60, 100')
          â””â”€â”€ it('returns false for regular days')

  Tareas AtÃ³micas para 04.8 Protocolo de 100 DÃ­as

  TAREA-04.8.1:
    Nombre: "Crear estructura para protocol"
    AcciÃ³n: "Crear carpeta y archivos"
    Responsable: Antigravity
    Comando: |
      mkdir -p src/lib/core/protocol
      touch src/lib/core/protocol/{index,types,constants,day-structure,milestones}.ts
      touch src/lib/core/protocol/protocol.test.ts
    Criterio de Ã‰xito: "Archivos existen"

  TAREA-04.8.2:
    Nombre: "Implementar types.ts para protocol"
    AcciÃ³n: "Definir tipos del protocolo"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/protocol/types.ts:

      export enum ProtocolPhase {
        TRIAL = 'trial',
        FOUNDATION = 'foundation',
        BUILDING = 'building',
        MASTERY = 'mastery',
        POST_GAME = 'post_game'
      }

      export interface PhaseInfo {
        phase: ProtocolPhase;
        name: string;
        startDay: number;
        endDay: number;
        description: string;
        difficultyMultiplier: number;
        tasksPerDay: number;
        unlockedFeatures: string[];
      }

      export interface DayConfig {
        dayNumber: number;
        phase: ProtocolPhase;
        requiredTasks: TaskCategory[];
        optionalTasks: TaskCategory[];
        specialEvent?: SpecialEvent;
        isPaywallDay: boolean;
      }

      export interface SpecialEvent {
        type: 'milestone' | 'challenge' | 'bonus';
        name: string;
        description: string;
        rewards: EventReward[];
      }

      export interface EventReward {
        type: 'btc' | 'item' | 'badge' | 'health';
        amount?: number;
        itemId?: string;
        badgeName?: string;
      }

      export interface MilestoneReport {
        dayNumber: number;
        event: SpecialEvent;
        message: string;
        rewards: EventReward[];
        stats: {
          daysCompleted: number;
          tasksCompleted: number;
          streakRecord: number;
          totalBtcEarned: number;
        };
      }
    Criterio de Ã‰xito: "Tipos compilan"

  TAREA-04.8.3:
    Nombre: "Implementar constants.ts para protocol"
    AcciÃ³n: "Definir configuraciÃ³n de fases"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/protocol/constants.ts:

      import { ProtocolPhase, PhaseInfo, SpecialEvent } from './types';

      export const PROTOCOL_CONFIG = {
        TOTAL_DAYS: 100,
        TRIAL_DAYS: 5,
        PAYWALL_DAY: 6,
        POST_GAME_START: 101
      } as const;

      export const PHASES: Record<ProtocolPhase, PhaseInfo> = {
        [ProtocolPhase.TRIAL]: {
          phase: ProtocolPhase.TRIAL,
          name: 'Prueba Gratuita',
          startDay: 1,
          endDay: 5,
          description: 'Conoce el sistema sin compromiso',
          difficultyMultiplier: 0.6,
          tasksPerDay: 3,
          unlockedFeatures: ['basic_tasks', 'avatar_preview']
        },
        [ProtocolPhase.FOUNDATION]: {
          phase: ProtocolPhase.FOUNDATION,
          name: 'FundaciÃ³n',
          startDay: 6,
          endDay: 30,
          description: 'Construye los cimientos de tu transformaciÃ³n',
          difficultyMultiplier: 0.8,
          tasksPerDay: 4,
          unlockedFeatures: ['full_tasks', 'store_basic', 'avatar_full']
        },
        [ProtocolPhase.BUILDING]: {
          phase: ProtocolPhase.BUILDING,
          name: 'ConstrucciÃ³n',
          startDay: 31,
          endDay: 60,
          description: 'Intensifica tu entrenamiento',
          difficultyMultiplier: 1.0,
          tasksPerDay: 5,
          unlockedFeatures: ['store_premium', 'advanced_stats']
        },
        [ProtocolPhase.MASTERY]: {
          phase: ProtocolPhase.MASTERY,
          name: 'MaestrÃ­a',
          startDay: 61,
          endDay: 100,
          description: 'Domina todos los aspectos',
          difficultyMultiplier: 1.2,
          tasksPerDay: 6,
          unlockedFeatures: ['elite_store', 'full_customization']
        },
        [ProtocolPhase.POST_GAME]: {
          phase: ProtocolPhase.POST_GAME,
          name: 'Post-Game',
          startDay: 101,
          endDay: Infinity,
          description: 'MantÃ©n tu grandeza eternamente',
          difficultyMultiplier: 1.5,
          tasksPerDay: 6,
          unlockedFeatures: ['infinite_mode', 'leaderboards', 'legacy_badges']
        }
      };

      export const SPECIAL_DAYS: Record<number, SpecialEvent> = {
        6: {
          type: 'milestone',
          name: 'DÃ­a de ConversiÃ³n',
          description: 'Tu viaje real comienza hoy',
          rewards: []
        },
        30: {
          type: 'milestone',
          name: 'Primer Mes',
          description: 'Un mes de disciplina inquebrantable',
          rewards: [
            { type: 'btc', amount: 1500 },
            { type: 'badge', badgeName: 'monthly_master' }
          ]
        },
        60: {
          type: 'milestone',
          name: 'Medio Camino',
          description: 'Has llegado a la mitad del protocolo',
          rewards: [
            { type: 'btc', amount: 3000 },
            { type: 'badge', badgeName: 'halfway_hero' }
          ]
        },
        100: {
          type: 'milestone',
          name: 'Victoria Final',
          description: 'Has completado el protocolo METAMEN100',
          rewards: [
            { type: 'btc', amount: 10000 },
            { type: 'badge', badgeName: 'centurion' },
            { type: 'item', itemId: 'crown_of_victory' }
          ]
        }
      };
    Criterio de Ã‰xito: "ConfiguraciÃ³n completa"

  TAREA-04.8.4:
    Nombre: "Implementar day-structure.ts"
    AcciÃ³n: "Funciones de estructura de dÃ­a"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/protocol/day-structure.ts:

      import { ProtocolPhase, PhaseInfo, DayConfig } from './types';
      import { PROTOCOL_CONFIG, PHASES, SPECIAL_DAYS } from './constants';
      import { TaskCategory, TaskArchetype } from '../vectors/types';

      export function getCurrentPhase(dayNumber: number): ProtocolPhase {
        if (dayNumber <= 5) return ProtocolPhase.TRIAL;
        if (dayNumber <= 30) return ProtocolPhase.FOUNDATION;
        if (dayNumber <= 60) return ProtocolPhase.BUILDING;
        if (dayNumber <= 100) return ProtocolPhase.MASTERY;
        return ProtocolPhase.POST_GAME;
      }

      export function getPhaseInfo(phase: ProtocolPhase): PhaseInfo {
        return PHASES[phase];
      }

      export function getPhaseInfoForDay(dayNumber: number): PhaseInfo {
        const phase = getCurrentPhase(dayNumber);
        return PHASES[phase];
      }

      // Tareas por arquetipo
      const TASKS_BY_ARCHETYPE: Record<TaskArchetype, TaskCategory[]> = {
        [TaskArchetype.MENTAL]: [
          TaskCategory.MEDITATION,
          TaskCategory.COLD_SHOWER,
          TaskCategory.READING,
          TaskCategory.WAKE_EARLY
        ],
        [TaskArchetype.CARA]: [
          TaskCategory.POSTURE,
          TaskCategory.FACIAL,
          TaskCategory.KEGEL
        ],
        [TaskArchetype.PRODUCTIVIDAD]: [
          TaskCategory.JOURNAL,
          TaskCategory.SKILL_LEARNING,
          TaskCategory.FOCUS_WORK
        ],
        [TaskArchetype.FISICO]: [
          TaskCategory.STRENGTH,
          TaskCategory.CARDIO,
          TaskCategory.HYDRATION
        ]
      };

      export function generateDailyTasks(dayNumber: number): {
        required: TaskCategory[];
        optional: TaskCategory[];
      } {
        const phase = getCurrentPhase(dayNumber);
        const phaseInfo = PHASES[phase];

        const required: TaskCategory[] = [];
        const optional: TaskCategory[] = [];

        // Usar el dÃ­a como seed para variar las tareas
        const seed = dayNumber % 100;

        switch (phase) {
          case ProtocolPhase.TRIAL:
            // 3 tareas: 1 Mental, 1 FÃ­sico, 1 opcional
            required.push(selectTask(TaskArchetype.MENTAL, seed));
            required.push(selectTask(TaskArchetype.FISICO, seed + 1));
            optional.push(selectTask(TaskArchetype.PRODUCTIVIDAD, seed + 2));
            break;

          case ProtocolPhase.FOUNDATION:
            // 4 tareas: 1 de cada arquetipo
            required.push(selectTask(TaskArchetype.MENTAL, seed));
            required.push(selectTask(TaskArchetype.CARA, seed + 1));
            required.push(selectTask(TaskArchetype.PRODUCTIVIDAD, seed + 2));
            required.push(selectTask(TaskArchetype.FISICO, seed + 3));
            break;

          case ProtocolPhase.BUILDING:
            // 5 tareas: 1 Mental, 1 Cara, 1 Productividad, 2 FÃ­sico
            required.push(selectTask(TaskArchetype.MENTAL, seed));
            required.push(selectTask(TaskArchetype.CARA, seed + 1));
            required.push(selectTask(TaskArchetype.PRODUCTIVIDAD, seed + 2));
            required.push(selectTask(TaskArchetype.FISICO, seed + 3));
            required.push(selectTask(TaskArchetype.FISICO, seed + 4));
            break;

          case ProtocolPhase.MASTERY:
          case ProtocolPhase.POST_GAME:
            // 6 tareas: 2 Mental, 1 Cara, 1 Productividad, 2 FÃ­sico
            required.push(selectTask(TaskArchetype.MENTAL, seed));
            required.push(selectTask(TaskArchetype.MENTAL, seed + 1));
            required.push(selectTask(TaskArchetype.CARA, seed + 2));
            required.push(selectTask(TaskArchetype.PRODUCTIVIDAD, seed + 3));
            required.push(selectTask(TaskArchetype.FISICO, seed + 4));
            required.push(selectTask(TaskArchetype.FISICO, seed + 5));
            break;
        }

        return { required, optional };
      }

      function selectTask(archetype: TaskArchetype, seed: number): TaskCategory {
        const tasks = TASKS_BY_ARCHETYPE[archetype];
        return tasks[seed % tasks.length];
      }

      export function getDayConfig(dayNumber: number): DayConfig {
        const phase = getCurrentPhase(dayNumber);
        const { required, optional } = generateDailyTasks(dayNumber);
        const specialEvent = SPECIAL_DAYS[dayNumber] ?? undefined;

        return {
          dayNumber,
          phase,
          requiredTasks: required,
          optionalTasks: optional,
          specialEvent,
          isPaywallDay: dayNumber === PROTOCOL_CONFIG.PAYWALL_DAY
        };
      }

      export function isPaywallDay(dayNumber: number): boolean {
        return dayNumber === PROTOCOL_CONFIG.PAYWALL_DAY;
      }

      export function isTrialExpired(dayNumber: number): boolean {
        return dayNumber > PROTOCOL_CONFIG.TRIAL_DAYS;
      }

      export function getProgressPercentage(dayNumber: number): number {
        return Math.min(100, Math.round((dayNumber / PROTOCOL_CONFIG.TOTAL_DAYS) * 100));
      }

      export function getDaysRemaining(dayNumber: number): number {
        return Math.max(0, PROTOCOL_CONFIG.TOTAL_DAYS - dayNumber);
      }

      export function isProtocolComplete(dayNumber: number): boolean {
        return dayNumber > PROTOCOL_CONFIG.TOTAL_DAYS;
      }
    Criterio de Ã‰xito: "Estructura de dÃ­as funciona"

  TAREA-04.8.5:
    Nombre: "Implementar milestones.ts"
    AcciÃ³n: "Funciones de hitos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/protocol/milestones.ts:

      import { SpecialEvent, EventReward, MilestoneReport } from './types';
      import { SPECIAL_DAYS } from './constants';

      export function getSpecialEvent(dayNumber: number): SpecialEvent | null {
        return SPECIAL_DAYS[dayNumber] ?? null;
      }

      export function isMilestoneDay(dayNumber: number): boolean {
        return dayNumber in SPECIAL_DAYS;
      }

      export function getMilestoneRewards(dayNumber: number): EventReward[] {
        const event = getSpecialEvent(dayNumber);
        return event?.rewards ?? [];
      }

      export const MILESTONE_MESSAGES: Record<number, string> = {
        6: 'Â¡Bienvenido al sistema completo! Tu viaje de 100 dÃ­as comienza ahora.',
        30: 'Â¡Primer mes completado! Has demostrado que la consistencia es tu nueva identidad.',
        60: 'Â¡Medio camino recorrido! Tu disciplina se ha vuelto inquebrantable.',
        100: 'Â¡VICTORIA ABSOLUTA! Has completado el protocolo METAMEN100. Eres leyenda.'
      };

      export function getMilestoneMessage(dayNumber: number): string | null {
        return MILESTONE_MESSAGES[dayNumber] ?? null;
      }

      interface UserStats {
        daysCompleted: number;
        tasksCompleted: number;
        streakRecord: number;
        totalBtcEarned: number;
      }

      export function generateMilestoneReport(
        dayNumber: number,
        stats: UserStats
      ): MilestoneReport | null {
        const event = getSpecialEvent(dayNumber);
        if (!event) return null;

        const message = getMilestoneMessage(dayNumber) ?? event.description;

        return {
          dayNumber,
          event,
          message,
          rewards: event.rewards,
          stats
        };
      }

      export function getAllUpcomingMilestones(currentDay: number): number[] {
        return Object.keys(SPECIAL_DAYS)
          .map(Number)
          .filter(day => day > currentDay)
          .sort((a, b) => a - b);
      }

      export function getNextMilestoneDay(currentDay: number): number | null {
        const upcoming = getAllUpcomingMilestones(currentDay);
        return upcoming[0] ?? null;
      }

      export function getDaysUntilNextMilestone(currentDay: number): number | null {
        const next = getNextMilestoneDay(currentDay);
        return next !== null ? next - currentDay : null;
      }
    Criterio de Ã‰xito: "Hitos funcionan"

  TAREA-04.8.6:
    Nombre: "Implementar index.ts para protocol"
    AcciÃ³n: "Exports pÃºblicos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/protocol/index.ts exportando todo lo pÃºblico:

      // Types
      export type { PhaseInfo, DayConfig, SpecialEvent, EventReward, MilestoneReport } from './types';
      export { ProtocolPhase } from './types';

      // Constants
      export { PROTOCOL_CONFIG, PHASES, SPECIAL_DAYS } from './constants';

      // Day Structure
      export {
        getCurrentPhase,
        getPhaseInfo,
        getPhaseInfoForDay,
        generateDailyTasks,
        getDayConfig,
        isPaywallDay,
        isTrialExpired,
        getProgressPercentage,
        getDaysRemaining,
        isProtocolComplete
      } from './day-structure';

      // Milestones
      export {
        getSpecialEvent,
        isMilestoneDay,
        getMilestoneRewards,
        getMilestoneMessage,
        generateMilestoneReport,
        getAllUpcomingMilestones,
        getNextMilestoneDay,
        getDaysUntilNextMilestone,
        MILESTONE_MESSAGES
      } from './milestones';
    Criterio de Ã‰xito: "Exports funcionan"

  TAREA-04.8.7:
    Nombre: "Implementar tests de protocol"
    AcciÃ³n: "Suite completa de tests"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/protocol/protocol.test.ts:

      import { describe, it, expect } from 'vitest';
      import {
        getCurrentPhase,
        generateDailyTasks,
        getDayConfig,
        isPaywallDay,
        isTrialExpired,
        getProgressPercentage,
        getDaysRemaining,
        isMilestoneDay,
        getNextMilestoneDay
      } from './index';
      import { ProtocolPhase } from './types';

      describe('getCurrentPhase', () => {
        it('returns TRIAL for days 1-5', () => {
          expect(getCurrentPhase(1)).toBe(ProtocolPhase.TRIAL);
          expect(getCurrentPhase(3)).toBe(ProtocolPhase.TRIAL);
          expect(getCurrentPhase(5)).toBe(ProtocolPhase.TRIAL);
        });

        it('returns FOUNDATION for days 6-30', () => {
          expect(getCurrentPhase(6)).toBe(ProtocolPhase.FOUNDATION);
          expect(getCurrentPhase(15)).toBe(ProtocolPhase.FOUNDATION);
          expect(getCurrentPhase(30)).toBe(ProtocolPhase.FOUNDATION);
        });

        it('returns BUILDING for days 31-60', () => {
          expect(getCurrentPhase(31)).toBe(ProtocolPhase.BUILDING);
          expect(getCurrentPhase(45)).toBe(ProtocolPhase.BUILDING);
          expect(getCurrentPhase(60)).toBe(ProtocolPhase.BUILDING);
        });

        it('returns MASTERY for days 61-100', () => {
          expect(getCurrentPhase(61)).toBe(ProtocolPhase.MASTERY);
          expect(getCurrentPhase(80)).toBe(ProtocolPhase.MASTERY);
          expect(getCurrentPhase(100)).toBe(ProtocolPhase.MASTERY);
        });

        it('returns POST_GAME for days 101+', () => {
          expect(getCurrentPhase(101)).toBe(ProtocolPhase.POST_GAME);
          expect(getCurrentPhase(150)).toBe(ProtocolPhase.POST_GAME);
        });
      });

      describe('generateDailyTasks', () => {
        it('generates 3 tasks for TRIAL phase', () => {
          const { required, optional } = generateDailyTasks(1);
          expect(required.length + optional.length).toBe(3);
        });

        it('generates 4 tasks for FOUNDATION phase', () => {
          const { required } = generateDailyTasks(10);
          expect(required.length).toBe(4);
        });

        it('generates 5 tasks for BUILDING phase', () => {
          const { required } = generateDailyTasks(40);
          expect(required.length).toBe(5);
        });

        it('generates 6 tasks for MASTERY phase', () => {
          const { required } = generateDailyTasks(80);
          expect(required.length).toBe(6);
        });

        it('generates different tasks for different days', () => {
          const day1 = generateDailyTasks(1);
          const day2 = generateDailyTasks(2);
          // Pueden ser diferentes (o iguales por casualidad, pero el seed varÃ­a)
          // Al menos verificamos que se generan
          expect(day1.required.length).toBeGreaterThan(0);
          expect(day2.required.length).toBeGreaterThan(0);
        });
      });

      describe('isPaywallDay', () => {
        it('returns true for day 6', () => {
          expect(isPaywallDay(6)).toBe(true);
        });

        it('returns false for other days', () => {
          expect(isPaywallDay(1)).toBe(false);
          expect(isPaywallDay(5)).toBe(false);
          expect(isPaywallDay(7)).toBe(false);
          expect(isPaywallDay(30)).toBe(false);
        });
      });

      describe('isTrialExpired', () => {
        it('returns false for days 1-5', () => {
          expect(isTrialExpired(1)).toBe(false);
          expect(isTrialExpired(5)).toBe(false);
        });

        it('returns true for day 6+', () => {
          expect(isTrialExpired(6)).toBe(true);
          expect(isTrialExpired(100)).toBe(true);
        });
      });

      describe('getProgressPercentage', () => {
        it('returns 1 for day 1', () => {
          expect(getProgressPercentage(1)).toBe(1);
        });

        it('returns 50 for day 50', () => {
          expect(getProgressPercentage(50)).toBe(50);
        });

        it('returns 100 for day 100', () => {
          expect(getProgressPercentage(100)).toBe(100);
        });

        it('caps at 100 for days > 100', () => {
          expect(getProgressPercentage(150)).toBe(100);
        });
      });

      describe('getDaysRemaining', () => {
        it('returns 99 for day 1', () => {
          expect(getDaysRemaining(1)).toBe(99);
        });

        it('returns 0 for day 100', () => {
          expect(getDaysRemaining(100)).toBe(0);
        });

        it('returns 0 for days > 100', () => {
          expect(getDaysRemaining(150)).toBe(0);
        });
      });

      describe('isMilestoneDay', () => {
        it('returns true for milestone days', () => {
          expect(isMilestoneDay(6)).toBe(true);
          expect(isMilestoneDay(30)).toBe(true);
          expect(isMilestoneDay(60)).toBe(true);
          expect(isMilestoneDay(100)).toBe(true);
        });

        it('returns false for regular days', () => {
          expect(isMilestoneDay(1)).toBe(false);
          expect(isMilestoneDay(15)).toBe(false);
          expect(isMilestoneDay(99)).toBe(false);
        });
      });

      describe('getNextMilestoneDay', () => {
        it('returns 6 for day 1', () => {
          expect(getNextMilestoneDay(1)).toBe(6);
        });

        it('returns 30 for day 10', () => {
          expect(getNextMilestoneDay(10)).toBe(30);
        });

        it('returns null after day 100', () => {
          expect(getNextMilestoneDay(101)).toBe(null);
        });
      });
    Criterio de Ã‰xito: "Todos los tests pasan"

  TAREA-04.8.8:
    Nombre: "Ejecutar tests de protocol"
    AcciÃ³n: "Verificar suite completa"
    Responsable: Antigravity
    Comando: |
      npm run test src/lib/core/protocol/protocol.test.ts
    Criterio de Ã‰xito: "100% tests pasan"

  ---
  SUBCAJA 04.9: VALIDACIONES DE NEGOCIO

  Reglas y Restricciones del Sistema

  Archivos a Crear

  Ruta: /src/lib/core/validations/
  â”œâ”€â”€ index.ts              (Exports pÃºblicos)
  â”œâ”€â”€ types.ts              (Tipos de validaciÃ³n)
  â”œâ”€â”€ task-validations.ts   (Validaciones de tareas)
  â”œâ”€â”€ purchase-validations.ts (Validaciones de compra)
  â”œâ”€â”€ subscription-validations.ts (Validaciones de suscripciÃ³n)
  â””â”€â”€ validations.test.ts   (Tests unitarios)

  TamaÃ±o Estimado: ~500 lÃ­neas total
  Tiempo de GeneraciÃ³n: 40-50 minutos

  Estructura del MÃ³dulo

  /src/lib/core/validations/
  â”‚
  â”œâ”€â”€ ğŸ“„ types.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ ValidationResult (interface)
  â”‚   â”‚   â”œâ”€â”€ valid: boolean
  â”‚   â”‚   â”œâ”€â”€ errorCode?: ValidationErrorCode
  â”‚   â”‚   â””â”€â”€ errorMessage?: string
  â”‚   â”‚
  â”‚   â”œâ”€â”€ ValidationErrorCode (enum)
  â”‚   â”‚   â”œâ”€â”€ // Tareas
  â”‚   â”‚   â”œâ”€â”€ AVATAR_DEAD = 'avatar_dead'
  â”‚   â”‚   â”œâ”€â”€ TASK_ALREADY_COMPLETED = 'task_already_completed'
  â”‚   â”‚   â”œâ”€â”€ TASK_NOT_AVAILABLE = 'task_not_available'
  â”‚   â”‚   â”œâ”€â”€ DAY_ALREADY_JUDGED = 'day_already_judged'
  â”‚   â”‚   â”œâ”€â”€ TRIAL_EXPIRED = 'trial_expired'
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // Compras
  â”‚   â”‚   â”œâ”€â”€ INSUFFICIENT_FUNDS = 'insufficient_funds'
  â”‚   â”‚   â”œâ”€â”€ ITEM_NOT_AVAILABLE = 'item_not_available'
  â”‚   â”‚   â”œâ”€â”€ ITEM_ALREADY_OWNED = 'item_already_owned'
  â”‚   â”‚   â”œâ”€â”€ LEVEL_REQUIREMENT_NOT_MET = 'level_requirement_not_met'
  â”‚   â”‚   â”œâ”€â”€ ITEM_LOCKED = 'item_locked'
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // SuscripciÃ³n
  â”‚   â”‚   â”œâ”€â”€ SUBSCRIPTION_REQUIRED = 'subscription_required'
  â”‚   â”‚   â”œâ”€â”€ SUBSCRIPTION_EXPIRED = 'subscription_expired'
  â”‚   â”‚   â”œâ”€â”€ LIMBO_STATUS = 'limbo_status'
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ // Equipamiento
  â”‚   â”‚   â”œâ”€â”€ NOT_IN_INVENTORY = 'not_in_inventory'
  â”‚   â”‚   â”œâ”€â”€ INCOMPATIBLE_SLOT = 'incompatible_slot'
  â”‚   â”‚   â”œâ”€â”€ SLOT_OCCUPIED = 'slot_occupied'
  â”‚   â”‚   â”‚
  â”‚   â”‚   â””â”€â”€ // General
  â”‚   â”‚   â””â”€â”€ UNKNOWN_ERROR = 'unknown_error'
  â”‚   â”‚
  â”‚   â””â”€â”€ ERROR_MESSAGES: Record<ValidationErrorCode, string>
  â”‚       â”œâ”€â”€ avatar_dead: "Tu avatar ha muerto. Debes resucitar para continuar."
  â”‚       â”œâ”€â”€ task_already_completed: "Esta tarea ya fue completada hoy."
  â”‚       â”œâ”€â”€ insufficient_funds: "No tienes suficiente BTC para esta compra."
  â”‚       â””â”€â”€ ... (todos los mensajes)
  â”‚
  â”œâ”€â”€ ğŸ“„ task-validations.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canCompleteTask(params: {
  â”‚   â”‚     avatarHealth: number,
  â”‚   â”‚     taskId: string,
  â”‚   â”‚     completedTasks: string[],
  â”‚   â”‚     dayStatus: DayStatus
  â”‚   â”‚   }): ValidationResult
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ Verificar avatar no muerto
  â”‚   â”‚   â”œâ”€â”€ Verificar tarea no completada
  â”‚   â”‚   â””â”€â”€ Verificar dÃ­a no juzgado
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canAccessDailyTasks(params: {
  â”‚   â”‚     subscriptionStatus: SubscriptionStatus,
  â”‚   â”‚     currentDay: number
  â”‚   â”‚   }): ValidationResult
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ Trial: permitir hasta dÃ­a 5
  â”‚   â”‚   â”œâ”€â”€ Active: permitir siempre
  â”‚   â”‚   â”œâ”€â”€ Limbo: permitir con advertencia
  â”‚   â”‚   â””â”€â”€ Cancelled: bloquear despuÃ©s de trial
  â”‚   â”‚
  â”‚   â””â”€â”€ canSkipTask(params: {
  â”‚       taskId: string,
  â”‚       skipsUsedToday: number,
  â”‚       maxDailySkips: number
  â”‚     }): ValidationResult
  â”‚
  â”œâ”€â”€ ğŸ“„ purchase-validations.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canPurchaseItem(params: {
  â”‚   â”‚     balance: number,
  â”‚   â”‚     itemPrice: number,
  â”‚   â”‚     userLevel: number,
  â”‚   â”‚     itemLevelRequired: number,
  â”‚   â”‚     inventory: string[],
  â”‚   â”‚     itemId: string,
  â”‚   â”‚     itemAvailable: boolean
  â”‚   â”‚   }): ValidationResult
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ Verificar item disponible
  â”‚   â”‚   â”œâ”€â”€ Verificar no ya poseÃ­do
  â”‚   â”‚   â”œâ”€â”€ Verificar nivel suficiente
  â”‚   â”‚   â””â”€â”€ Verificar balance suficiente
  â”‚   â”‚
  â”‚   â””â”€â”€ canEquipItem(params: {
  â”‚       itemId: string,
  â”‚       inventory: InventoryItem[],
  â”‚       userLevel: number,
  â”‚       itemLevelRequired: number,
  â”‚       targetSlot: string,
  â”‚       currentlyEquipped: EquippedItems
  â”‚     }): ValidationResult
  â”‚
  â”œâ”€â”€ ğŸ“„ subscription-validations.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ isTrialExpired(currentDay: number): boolean
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canAccessPremiumFeatures(params: {
  â”‚   â”‚     subscriptionStatus: SubscriptionStatus,
  â”‚   â”‚     currentDay: number
  â”‚   â”‚   }): ValidationResult
  â”‚   â”‚
  â”‚   â”œâ”€â”€ shouldShowPaywall(params: {
  â”‚   â”‚     subscriptionStatus: SubscriptionStatus,
  â”‚   â”‚     currentDay: number
  â”‚   â”‚   }): boolean
  â”‚   â”‚
  â”‚   â””â”€â”€ getLimboGracePeriod(limboDayCount: number): {
  â”‚       daysRemaining: number,
  â”‚       healthAtRisk: number
  â”‚     }
  â”‚
  â””â”€â”€ ğŸ“„ validations.test.ts
      â”‚
      â”œâ”€â”€ describe('canCompleteTask')
      â”‚   â”œâ”€â”€ it('returns valid for alive avatar with incomplete task')
      â”‚   â”œâ”€â”€ it('returns invalid for dead avatar')
      â”‚   â”œâ”€â”€ it('returns invalid for already completed task')
      â”‚   â””â”€â”€ it('returns invalid for judged day')
      â”‚
      â”œâ”€â”€ describe('canPurchaseItem')
      â”‚   â”œâ”€â”€ it('returns valid when all conditions met')
      â”‚   â”œâ”€â”€ it('returns invalid for insufficient funds')
      â”‚   â”œâ”€â”€ it('returns invalid for level requirement not met')
      â”‚   â””â”€â”€ it('returns invalid for item already owned')
      â”‚
      â””â”€â”€ describe('canAccessPremiumFeatures')
          â”œâ”€â”€ it('returns valid for active subscription')
          â”œâ”€â”€ it('returns valid for trial within 5 days')
          â”œâ”€â”€ it('returns invalid for expired trial')
          â””â”€â”€ it('returns warning for limbo status')

  Tareas AtÃ³micas para 04.9 Validaciones de Negocio

  TAREA-04.9.1:
    Nombre: "Crear estructura para validations"
    AcciÃ³n: "Crear carpeta y archivos"
    Responsable: Antigravity
    Comando: |
      mkdir -p src/lib/core/validations
      touch src/lib/core/validations/{index,types,task-validations,purchase-validations,subscription-validations}.ts
      touch src/lib/core/validations/validations.test.ts
    Criterio de Ã‰xito: "Archivos existen"

  TAREA-04.9.2:
    Nombre: "Implementar types.ts para validations"
    AcciÃ³n: "Definir tipos de validaciÃ³n"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/validations/types.ts:

      export interface ValidationResult {
        valid: boolean;
        errorCode?: ValidationErrorCode;
        errorMessage?: string;
        warningMessage?: string;
      }

      export enum ValidationErrorCode {
        // Tareas
        AVATAR_DEAD = 'avatar_dead',
        TASK_ALREADY_COMPLETED = 'task_already_completed',
        TASK_NOT_AVAILABLE = 'task_not_available',
        DAY_ALREADY_JUDGED = 'day_already_judged',
        TRIAL_EXPIRED = 'trial_expired',
        MAX_SKIPS_REACHED = 'max_skips_reached',

        // Compras
        INSUFFICIENT_FUNDS = 'insufficient_funds',
        ITEM_NOT_AVAILABLE = 'item_not_available',
        ITEM_ALREADY_OWNED = 'item_already_owned',
        LEVEL_REQUIREMENT_NOT_MET = 'level_requirement_not_met',
        ITEM_LOCKED = 'item_locked',

        // SuscripciÃ³n
        SUBSCRIPTION_REQUIRED = 'subscription_required',
        SUBSCRIPTION_EXPIRED = 'subscription_expired',
        LIMBO_STATUS = 'limbo_status',

        // Equipamiento
        NOT_IN_INVENTORY = 'not_in_inventory',
        INCOMPATIBLE_SLOT = 'incompatible_slot',
        SLOT_OCCUPIED = 'slot_occupied',

        // General
        UNKNOWN_ERROR = 'unknown_error'
      }

      export const ERROR_MESSAGES: Record<ValidationErrorCode, string> = {
        [ValidationErrorCode.AVATAR_DEAD]: 'Tu avatar ha muerto. Debes resucitar para continuar.',
        [ValidationErrorCode.TASK_ALREADY_COMPLETED]: 'Esta tarea ya fue completada hoy.',
        [ValidationErrorCode.TASK_NOT_AVAILABLE]: 'Esta tarea no estÃ¡ disponible hoy.',
        [ValidationErrorCode.DAY_ALREADY_JUDGED]: 'El dÃ­a ya ha sido evaluado.',
        [ValidationErrorCode.TRIAL_EXPIRED]: 'Tu perÃ­odo de prueba ha expirado. SuscrÃ­bete para continuar.',
        [ValidationErrorCode.MAX_SKIPS_REACHED]: 'Has alcanzado el mÃ¡ximo de saltos permitidos hoy.',

        [ValidationErrorCode.INSUFFICIENT_FUNDS]: 'No tienes suficiente BTC para esta compra.',
        [ValidationErrorCode.ITEM_NOT_AVAILABLE]: 'Este artÃ­culo no estÃ¡ disponible actualmente.',
        [ValidationErrorCode.ITEM_ALREADY_OWNED]: 'Ya posees este artÃ­culo.',
        [ValidationErrorCode.LEVEL_REQUIREMENT_NOT_MET]: 'No cumples con el nivel requerido para este artÃ­culo.',
        [ValidationErrorCode.ITEM_LOCKED]: 'Este artÃ­culo estÃ¡ bloqueado. Sube de nivel para desbloquearlo.',

        [ValidationErrorCode.SUBSCRIPTION_REQUIRED]: 'Necesitas una suscripciÃ³n activa para acceder a esta funciÃ³n.',
        [ValidationErrorCode.SUBSCRIPTION_EXPIRED]: 'Tu suscripciÃ³n ha expirado.',
        [ValidationErrorCode.LIMBO_STATUS]: 'Tu suscripciÃ³n estÃ¡ en estado limbo. Actualiza tu pago.',

        [ValidationErrorCode.NOT_IN_INVENTORY]: 'No tienes este artÃ­culo en tu inventario.',
        [ValidationErrorCode.INCOMPATIBLE_SLOT]: 'Este artÃ­culo no es compatible con el slot seleccionado.',
        [ValidationErrorCode.SLOT_OCCUPIED]: 'Este slot ya tiene un artÃ­culo equipado.',

        [ValidationErrorCode.UNKNOWN_ERROR]: 'Ha ocurrido un error desconocido.'
      };

      export function createValidResult(): ValidationResult {
        return { valid: true };
      }

      export function createInvalidResult(
        errorCode: ValidationErrorCode,
        customMessage?: string
      ): ValidationResult {
        return {
          valid: false,
          errorCode,
          errorMessage: customMessage ?? ERROR_MESSAGES[errorCode]
        };
      }

      export function createWarningResult(warningMessage: string): ValidationResult {
        return { valid: true, warningMessage };
      }
    Criterio de Ã‰xito: "Tipos compilan"

  TAREA-04.9.3:
    Nombre: "Implementar task-validations.ts"
    AcciÃ³n: "Validaciones de tareas"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/validations/task-validations.ts:

      import { ValidationResult, ValidationErrorCode, createValidResult, createInvalidResult } from './types';
      import { DayStatus } from '../judgement/types';
      import { SubscriptionStatus } from '../types/subscription';
      import { isTrialExpired as checkTrialExpired } from '../protocol';

      interface CanCompleteTaskParams {
        avatarHealth: number;
        taskId: string;
        completedTasks: string[];
        dayStatus: DayStatus;
      }

      export function canCompleteTask(params: CanCompleteTaskParams): ValidationResult {
        const { avatarHealth, taskId, completedTasks, dayStatus } = params;

        // Avatar muerto
        if (avatarHealth <= 0) {
          return createInvalidResult(ValidationErrorCode.AVATAR_DEAD);
        }

        // Tarea ya completada
        if (completedTasks.includes(taskId)) {
          return createInvalidResult(ValidationErrorCode.TASK_ALREADY_COMPLETED);
        }

        // DÃ­a ya juzgado
        if (dayStatus !== 'active') {
          return createInvalidResult(ValidationErrorCode.DAY_ALREADY_JUDGED);
        }

        return createValidResult();
      }

      interface CanAccessDailyTasksParams {
        subscriptionStatus: SubscriptionStatus;
        currentDay: number;
      }

      export function canAccessDailyTasks(params: CanAccessDailyTasksParams): ValidationResult {
        const { subscriptionStatus, currentDay } = params;

        switch (subscriptionStatus) {
          case 'active':
            return createValidResult();

          case 'trial':
            if (checkTrialExpired(currentDay)) {
              return createInvalidResult(ValidationErrorCode.TRIAL_EXPIRED);
            }
            return createValidResult();

          case 'limbo':
            return {
              valid: true,
              warningMessage: 'Tu suscripciÃ³n necesita atenciÃ³n. Actualiza tu pago para evitar perder corazones.'
            };

          case 'cancelled':
          case 'expired':
            return createInvalidResult(ValidationErrorCode.SUBSCRIPTION_EXPIRED);

          default:
            return createInvalidResult(ValidationErrorCode.SUBSCRIPTION_REQUIRED);
        }
      }

      interface CanSkipTaskParams {
        taskId: string;
        skipsUsedToday: number;
        maxDailySkips: number;
      }

      export function canSkipTask(params: CanSkipTaskParams): ValidationResult {
        const { skipsUsedToday, maxDailySkips } = params;

        if (skipsUsedToday >= maxDailySkips) {
          return createInvalidResult(
            ValidationErrorCode.MAX_SKIPS_REACHED,
            `Has alcanzado el mÃ¡ximo de ${maxDailySkips} saltos por dÃ­a.`
          );
        }

        return createValidResult();
      }
    Criterio de Ã‰xito: "Validaciones de tareas funcionan"

  TAREA-04.9.4:
    Nombre: "Implementar purchase-validations.ts"
    AcciÃ³n: "Validaciones de compras"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/validations/purchase-validations.ts:

      import { ValidationResult, ValidationErrorCode, createValidResult, createInvalidResult } from './types';

      interface CanPurchaseItemParams {
        balance: number;
        itemPrice: number;
        userLevel: number;
        itemLevelRequired: number;
        inventory: string[];
        itemId: string;
        itemAvailable: boolean;
      }

      export function canPurchaseItem(params: CanPurchaseItemParams): ValidationResult {
        const { balance, itemPrice, userLevel, itemLevelRequired, inventory, itemId, itemAvailable } = params;

        // Item no disponible
        if (!itemAvailable) {
          return createInvalidResult(ValidationErrorCode.ITEM_NOT_AVAILABLE);
        }

        // Ya lo posee
        if (inventory.includes(itemId)) {
          return createInvalidResult(ValidationErrorCode.ITEM_ALREADY_OWNED);
        }

        // Nivel insuficiente
        if (userLevel < itemLevelRequired) {
          return createInvalidResult(
            ValidationErrorCode.LEVEL_REQUIREMENT_NOT_MET,
            `Necesitas nivel ${itemLevelRequired} para comprar este artÃ­culo. Tu nivel actual: ${userLevel}.`
          );
        }

        // Fondos insuficientes
        if (balance < itemPrice) {
          return createInvalidResult(
            ValidationErrorCode.INSUFFICIENT_FUNDS,
            `Necesitas ${itemPrice} BTC pero tienes ${balance} BTC.`
          );
        }

        return createValidResult();
      }

      interface InventoryItem {
        id: string;
        levelRequired: number;
        slot: string;
      }

      interface EquippedItems {
        [slot: string]: string | null; // slot -> itemId
      }

      interface CanEquipItemParams {
        itemId: string;
        inventory: InventoryItem[];
        userLevel: number;
        targetSlot: string;
        currentlyEquipped: EquippedItems;
      }

      export function canEquipItem(params: CanEquipItemParams): ValidationResult {
        const { itemId, inventory, userLevel, targetSlot, currentlyEquipped } = params;

        // Buscar item en inventario
        const item = inventory.find(i => i.id === itemId);

        if (!item) {
          return createInvalidResult(ValidationErrorCode.NOT_IN_INVENTORY);
        }

        // Nivel bloqueado (despuÃ©s de muerte)
        if (userLevel < item.levelRequired) {
          return createInvalidResult(
            ValidationErrorCode.ITEM_LOCKED,
            `Este artÃ­culo requiere nivel ${item.levelRequired}. Sube de nivel para desbloquearlo.`
          );
        }

        // Slot incompatible
        if (item.slot !== targetSlot) {
          return createInvalidResult(
            ValidationErrorCode.INCOMPATIBLE_SLOT,
            `Este artÃ­culo es para el slot "${item.slot}", no para "${targetSlot}".`
          );
        }

        // Slot ocupado (advertencia, no error)
        if (currentlyEquipped[targetSlot] && currentlyEquipped[targetSlot] !== itemId) {
          return {
            valid: true,
            warningMessage: `El slot "${targetSlot}" ya tiene un artÃ­culo. Se reemplazarÃ¡.`
          };
        }

        return createValidResult();
      }

      export function getLockedItemsAtLevel(
        inventory: InventoryItem[],
        currentLevel: number
      ): InventoryItem[] {
        return inventory.filter(item => item.levelRequired > currentLevel);
      }
    Criterio de Ã‰xito: "Validaciones de compras funcionan"

  TAREA-04.9.5:
    Nombre: "Implementar subscription-validations.ts"
    AcciÃ³n: "Validaciones de suscripciÃ³n"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/validations/subscription-validations.ts:

      import { ValidationResult, ValidationErrorCode, createValidResult, createInvalidResult } from './types';
      import { PROTOCOL_CONFIG } from '../protocol/constants';

      type SubscriptionStatus = 'trial' | 'active' | 'limbo' | 'past_due' | 'cancelled' | 'expired';

      export function isTrialExpired(currentDay: number): boolean {
        return currentDay > PROTOCOL_CONFIG.TRIAL_DAYS;
      }

      interface CanAccessPremiumParams {
        subscriptionStatus: SubscriptionStatus;
        currentDay: number;
      }

      export function canAccessPremiumFeatures(params: CanAccessPremiumParams): ValidationResult {
        const { subscriptionStatus, currentDay } = params;

        switch (subscriptionStatus) {
          case 'active':
            return createValidResult();

          case 'trial':
            if (isTrialExpired(currentDay)) {
              return createInvalidResult(
                ValidationErrorCode.TRIAL_EXPIRED,
                'Tu perÃ­odo de prueba ha terminado. SuscrÃ­bete para desbloquear todas las funciones.'
              );
            }
            return createValidResult();

          case 'limbo':
          case 'past_due':
            return {
              valid: true,
              warningMessage: 'Tu pago estÃ¡ pendiente. Actualiza tu mÃ©todo de pago para evitar pÃ©rdida de acceso.'
            };

          case 'cancelled':
          case 'expired':
            return createInvalidResult(ValidationErrorCode.SUBSCRIPTION_EXPIRED);

          default:
            return createInvalidResult(ValidationErrorCode.SUBSCRIPTION_REQUIRED);
        }
      }

      interface ShouldShowPaywallParams {
        subscriptionStatus: SubscriptionStatus;
        currentDay: number;
      }

      export function shouldShowPaywall(params: ShouldShowPaywallParams): boolean {
        const { subscriptionStatus, currentDay } = params;

        // No mostrar paywall a usuarios activos
        if (subscriptionStatus === 'active') return false;

        // Mostrar paywall en dÃ­a 6 (dÃ­a de conversiÃ³n)
        if (currentDay === PROTOCOL_CONFIG.PAYWALL_DAY) return true;

        // Mostrar si trial expirado y no suscrito
        if (isTrialExpired(currentDay) && subscriptionStatus === 'trial') return true;

        // Mostrar si suscripciÃ³n expirada
        if (subscriptionStatus === 'expired' || subscriptionStatus === 'cancelled') return true;

        return false;
      }

      const LIMBO_CONFIG = {
        GRACE_PERIOD_DAYS: 7,
        HEALTH_LOSS_PER_3_DAYS: 1
      };

      export function getLimboGracePeriod(limboDayCount: number): {
        daysRemaining: number;
        healthAtRisk: number;
        isGracePeriodOver: boolean;
      } {
        const daysRemaining = Math.max(0, LIMBO_CONFIG.GRACE_PERIOD_DAYS - limboDayCount);
        const healthAtRisk = Math.floor(limboDayCount / 3) * LIMBO_CONFIG.HEALTH_LOSS_PER_3_DAYS;
        const isGracePeriodOver = limboDayCount >= LIMBO_CONFIG.GRACE_PERIOD_DAYS;

        return { daysRemaining, healthAtRisk, isGracePeriodOver };
      }

      export function getSubscriptionRequirementMessage(feature: string): string {
        return `La funciÃ³n "${feature}" requiere una suscripciÃ³n activa.`;
      }
    Criterio de Ã‰xito: "Validaciones de suscripciÃ³n funcionan"

  TAREA-04.9.6:
    Nombre: "Implementar index.ts para validations"
    AcciÃ³n: "Exports pÃºblicos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/validations/index.ts:

      // Types
      export type { ValidationResult } from './types';
      export { ValidationErrorCode, ERROR_MESSAGES, createValidResult, createInvalidResult, createWarningResult } from './types';

      // Task Validations
      export { canCompleteTask, canAccessDailyTasks, canSkipTask } from './task-validations';

      // Purchase Validations
      export { canPurchaseItem, canEquipItem, getLockedItemsAtLevel } from './purchase-validations';

      // Subscription Validations
      export {
        isTrialExpired,
        canAccessPremiumFeatures,
        shouldShowPaywall,
        getLimboGracePeriod,
        getSubscriptionRequirementMessage
      } from './subscription-validations';
    Criterio de Ã‰xito: "Exports funcionan"

  TAREA-04.9.7:
    Nombre: "Implementar tests de validations"
    AcciÃ³n: "Suite completa de tests"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/validations/validations.test.ts con tests para:

      1. canCompleteTask
         - valid: avatar vivo, tarea no completada, dÃ­a activo
         - invalid: avatar muerto
         - invalid: tarea ya completada
         - invalid: dÃ­a ya juzgado

      2. canPurchaseItem
         - valid: todas las condiciones cumplen
         - invalid: fondos insuficientes
         - invalid: nivel no alcanzado
         - invalid: ya poseÃ­do
         - invalid: no disponible

      3. canEquipItem
         - valid: item en inventario, nivel suficiente
         - invalid: no en inventario
         - invalid: nivel bloqueado
         - warning: slot ocupado

      4. canAccessPremiumFeatures
         - valid: suscripciÃ³n activa
         - valid: trial dentro de 5 dÃ­as
         - invalid: trial expirado
         - warning: limbo

      5. shouldShowPaywall
         - true: dÃ­a 6 sin suscripciÃ³n
         - true: trial expirado
         - false: suscripciÃ³n activa
    Criterio de Ã‰xito: "Todos los tests pasan"

  TAREA-04.9.8:
    Nombre: "Ejecutar tests de validations"
    AcciÃ³n: "Verificar suite completa"
    Responsable: Antigravity
    Comando: |
      npm run test src/lib/core/validations/validations.test.ts
    Criterio de Ã‰xito: "100% tests pasan"

  ---
  SUBCAJA 04.10: MÃQUINAS DE ESTADO

  Control de Flujos y Transiciones

  Archivos a Crear

  Ruta: /src/lib/core/state-machines/
  â”œâ”€â”€ index.ts              (Exports pÃºblicos)
  â”œâ”€â”€ types.ts              (Tipos de mÃ¡quinas)
  â”œâ”€â”€ task-machine.ts       (Estados de tareas)
  â”œâ”€â”€ subscription-machine.ts (Estados de suscripciÃ³n)
  â”œâ”€â”€ image-machine.ts      (Estados de generaciÃ³n de imagen)
  â””â”€â”€ state-machines.test.ts (Tests unitarios)

  TamaÃ±o Estimado: ~550 lÃ­neas total
  Tiempo de GeneraciÃ³n: 45-55 minutos

  Estructura del MÃ³dulo

  /src/lib/core/state-machines/
  â”‚
  â”œâ”€â”€ ğŸ“„ types.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ StateMachineDefinition<S, E> (interface)
  â”‚   â”‚   â”œâ”€â”€ initialState: S
  â”‚   â”‚   â”œâ”€â”€ states: Record<S, StateConfig<S, E>>
  â”‚   â”‚   â””â”€â”€ onTransition?: (from: S, to: S, event: E) => void
  â”‚   â”‚
  â”‚   â”œâ”€â”€ StateConfig<S, E> (interface)
  â”‚   â”‚   â”œâ”€â”€ on: Record<E, S | TransitionConfig<S>>
  â”‚   â”‚   â””â”€â”€ onEnter?: () => void
  â”‚   â”‚
  â”‚   â”œâ”€â”€ TransitionConfig<S> (interface)
  â”‚   â”‚   â”œâ”€â”€ target: S
  â”‚   â”‚   â”œâ”€â”€ guard?: () => boolean
  â”‚   â”‚   â””â”€â”€ action?: () => void
  â”‚   â”‚
  â”‚   â””â”€â”€ TransitionResult<S> (interface)
  â”‚       â”œâ”€â”€ success: boolean
  â”‚       â”œâ”€â”€ previousState: S
  â”‚       â”œâ”€â”€ currentState: S
  â”‚       â”œâ”€â”€ event: string
  â”‚       â””â”€â”€ error?: string
  â”‚
  â”œâ”€â”€ ğŸ“„ task-machine.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ TaskState (enum)
  â”‚   â”‚   â”œâ”€â”€ PENDING = 'pending'
  â”‚   â”‚   â”œâ”€â”€ IN_PROGRESS = 'in_progress'
  â”‚   â”‚   â”œâ”€â”€ COMPLETED = 'completed'
  â”‚   â”‚   â”œâ”€â”€ SKIPPED = 'skipped'
  â”‚   â”‚   â””â”€â”€ FAILED = 'failed'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ TaskEvent (enum)
  â”‚   â”‚   â”œâ”€â”€ START = 'start'
  â”‚   â”‚   â”œâ”€â”€ COMPLETE = 'complete'
  â”‚   â”‚   â”œâ”€â”€ SKIP = 'skip'
  â”‚   â”‚   â”œâ”€â”€ FAIL = 'fail'
  â”‚   â”‚   â”œâ”€â”€ RESET = 'reset'
  â”‚   â”‚   â””â”€â”€ CANCEL = 'cancel'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ TASK_STATE_MACHINE
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ PENDING
  â”‚   â”‚   â”‚   â”œâ”€â”€ START â†’ IN_PROGRESS
  â”‚   â”‚   â”‚   â”œâ”€â”€ SKIP â†’ SKIPPED
  â”‚   â”‚   â”‚   â””â”€â”€ FAIL â†’ FAILED (por Judgement Night)
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ IN_PROGRESS
  â”‚   â”‚   â”‚   â”œâ”€â”€ COMPLETE â†’ COMPLETED
  â”‚   â”‚   â”‚   â”œâ”€â”€ CANCEL â†’ PENDING
  â”‚   â”‚   â”‚   â””â”€â”€ FAIL â†’ FAILED
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ COMPLETED (estado final)
  â”‚   â”‚   â”‚   â””â”€â”€ RESET â†’ PENDING (solo para nuevo dÃ­a)
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ SKIPPED (estado final)
  â”‚   â”‚   â”‚   â””â”€â”€ RESET â†’ PENDING
  â”‚   â”‚   â”‚
  â”‚   â”‚   â””â”€â”€ FAILED (estado final)
  â”‚   â”‚       â””â”€â”€ RESET â†’ PENDING
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canTransitionTask(
  â”‚   â”‚     currentState: TaskState,
  â”‚   â”‚     event: TaskEvent
  â”‚   â”‚   ): boolean
  â”‚   â”‚
  â”‚   â”œâ”€â”€ transitionTask(
  â”‚   â”‚     currentState: TaskState,
  â”‚   â”‚     event: TaskEvent
  â”‚   â”‚   ): TransitionResult<TaskState>
  â”‚   â”‚
  â”‚   â””â”€â”€ getValidTaskEvents(
  â”‚       currentState: TaskState
  â”‚     ): TaskEvent[]
  â”‚
  â”œâ”€â”€ ğŸ“„ subscription-machine.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ SubscriptionState (enum)
  â”‚   â”‚   â”œâ”€â”€ TRIAL = 'trial'
  â”‚   â”‚   â”œâ”€â”€ ACTIVE = 'active'
  â”‚   â”‚   â”œâ”€â”€ PAST_DUE = 'past_due'
  â”‚   â”‚   â”œâ”€â”€ LIMBO = 'limbo'
  â”‚   â”‚   â”œâ”€â”€ CANCELLED = 'cancelled'
  â”‚   â”‚   â””â”€â”€ EXPIRED = 'expired'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ SubscriptionEvent (enum)
  â”‚   â”‚   â”œâ”€â”€ SUBSCRIBE = 'subscribe'
  â”‚   â”‚   â”œâ”€â”€ PAYMENT_SUCCESS = 'payment_success'
  â”‚   â”‚   â”œâ”€â”€ PAYMENT_FAILED = 'payment_failed'
  â”‚   â”‚   â”œâ”€â”€ CANCEL = 'cancel'
  â”‚   â”‚   â”œâ”€â”€ REACTIVATE = 'reactivate'
  â”‚   â”‚   â”œâ”€â”€ TRIAL_EXPIRED = 'trial_expired'
  â”‚   â”‚   â””â”€â”€ GRACE_PERIOD_EXPIRED = 'grace_period_expired'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ SUBSCRIPTION_STATE_MACHINE
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ TRIAL
  â”‚   â”‚   â”‚   â”œâ”€â”€ SUBSCRIBE â†’ ACTIVE
  â”‚   â”‚   â”‚   â””â”€â”€ TRIAL_EXPIRED â†’ EXPIRED
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ ACTIVE
  â”‚   â”‚   â”‚   â”œâ”€â”€ PAYMENT_FAILED â†’ PAST_DUE
  â”‚   â”‚   â”‚   â””â”€â”€ CANCEL â†’ CANCELLED
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ PAST_DUE
  â”‚   â”‚   â”‚   â”œâ”€â”€ PAYMENT_SUCCESS â†’ ACTIVE
  â”‚   â”‚   â”‚   â””â”€â”€ GRACE_PERIOD_EXPIRED â†’ LIMBO
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ LIMBO
  â”‚   â”‚   â”‚   â”œâ”€â”€ PAYMENT_SUCCESS â†’ ACTIVE
  â”‚   â”‚   â”‚   â””â”€â”€ GRACE_PERIOD_EXPIRED â†’ EXPIRED
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ CANCELLED
  â”‚   â”‚   â”‚   â””â”€â”€ REACTIVATE â†’ ACTIVE
  â”‚   â”‚   â”‚
  â”‚   â”‚   â””â”€â”€ EXPIRED (estado final)
  â”‚   â”‚       â””â”€â”€ SUBSCRIBE â†’ ACTIVE
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canTransitionSubscription(...)
  â”‚   â”œâ”€â”€ transitionSubscription(...)
  â”‚   â””â”€â”€ getValidSubscriptionEvents(...)
  â”‚
  â”œâ”€â”€ ğŸ“„ image-machine.ts
  â”‚   â”‚
  â”‚   â”œâ”€â”€ ImageGenState (enum)
  â”‚   â”‚   â”œâ”€â”€ IDLE = 'idle'
  â”‚   â”‚   â”œâ”€â”€ QUEUED = 'queued'
  â”‚   â”‚   â”œâ”€â”€ GENERATING = 'generating'
  â”‚   â”‚   â”œâ”€â”€ COMPLETED = 'completed'
  â”‚   â”‚   â””â”€â”€ FAILED = 'failed'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ ImageGenEvent (enum)
  â”‚   â”‚   â”œâ”€â”€ REQUEST = 'request'
  â”‚   â”‚   â”œâ”€â”€ PROCESS_START = 'process_start'
  â”‚   â”‚   â”œâ”€â”€ PROCESS_COMPLETE = 'process_complete'
  â”‚   â”‚   â”œâ”€â”€ PROCESS_FAIL = 'process_fail'
  â”‚   â”‚   â””â”€â”€ RESET = 'reset'
  â”‚   â”‚
  â”‚   â”œâ”€â”€ IMAGE_GEN_STATE_MACHINE
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ IDLE
  â”‚   â”‚   â”‚   â””â”€â”€ REQUEST â†’ QUEUED
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ QUEUED
  â”‚   â”‚   â”‚   â””â”€â”€ PROCESS_START â†’ GENERATING
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ GENERATING
  â”‚   â”‚   â”‚   â”œâ”€â”€ PROCESS_COMPLETE â†’ COMPLETED
  â”‚   â”‚   â”‚   â””â”€â”€ PROCESS_FAIL â†’ FAILED
  â”‚   â”‚   â”‚
  â”‚   â”‚   â”œâ”€â”€ COMPLETED
  â”‚   â”‚   â”‚   â”œâ”€â”€ REQUEST â†’ QUEUED
  â”‚   â”‚   â”‚   â””â”€â”€ RESET â†’ IDLE
  â”‚   â”‚   â”‚
  â”‚   â”‚   â””â”€â”€ FAILED
  â”‚   â”‚       â”œâ”€â”€ REQUEST â†’ QUEUED (retry)
  â”‚   â”‚       â””â”€â”€ RESET â†’ IDLE
  â”‚   â”‚
  â”‚   â”œâ”€â”€ canTransitionImageGen(...)
  â”‚   â”œâ”€â”€ transitionImageGen(...)
  â”‚   â””â”€â”€ getValidImageGenEvents(...)
  â”‚
  â””â”€â”€ ğŸ“„ state-machines.test.ts
      â”‚
      â”œâ”€â”€ describe('Task State Machine')
      â”‚   â”œâ”€â”€ it('transitions PENDING â†’ IN_PROGRESS on START')
      â”‚   â”œâ”€â”€ it('transitions IN_PROGRESS â†’ COMPLETED on COMPLETE')
      â”‚   â”œâ”€â”€ it('prevents invalid transitions')
      â”‚   â”œâ”€â”€ it('allows RESET from terminal states')
      â”‚   â””â”€â”€ it('returns correct valid events for each state')
      â”‚
      â”œâ”€â”€ describe('Subscription State Machine')
      â”‚   â”œâ”€â”€ it('transitions TRIAL â†’ ACTIVE on SUBSCRIBE')
      â”‚   â”œâ”€â”€ it('transitions ACTIVE â†’ PAST_DUE on PAYMENT_FAILED')
      â”‚   â”œâ”€â”€ it('transitions PAST_DUE â†’ LIMBO after grace period')
      â”‚   â”œâ”€â”€ it('allows recovery from LIMBO with payment')
      â”‚   â””â”€â”€ it('transitions to EXPIRED correctly')
      â”‚
      â””â”€â”€ describe('Image Gen State Machine')
          â”œâ”€â”€ it('follows happy path: IDLE â†’ QUEUED â†’ GENERATING â†’ COMPLETED')
          â”œâ”€â”€ it('handles failure: GENERATING â†’ FAILED')
          â”œâ”€â”€ it('allows retry from FAILED')
          â””â”€â”€ it('allows new request from COMPLETED')

  Tareas AtÃ³micas para 04.10 MÃ¡quinas de Estado

  TAREA-04.10.1:
    Nombre: "Crear estructura para state-machines"
    AcciÃ³n: "Crear carpeta y archivos"
    Responsable: Antigravity
    Comando: |
      mkdir -p src/lib/core/state-machines
      touch src/lib/core/state-machines/{index,types,task-machine,subscription-machine,image-machine}.ts
      touch src/lib/core/state-machines/state-machines.test.ts
    Criterio de Ã‰xito: "Archivos existen"

  TAREA-04.10.2:
    Nombre: "Implementar types.ts para state-machines"
    AcciÃ³n: "Definir tipos genÃ©ricos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/state-machines/types.ts:

      export interface TransitionResult<S extends string> {
        success: boolean;
        previousState: S;
        currentState: S;
        event: string;
        error?: string;
      }

      export interface StateDefinition<S extends string, E extends string> {
        on: Partial<Record<E, S>>;
        isFinal?: boolean;
      }

      export interface StateMachineConfig<S extends string, E extends string> {
        initialState: S;
        states: Record<S, StateDefinition<S, E>>;
      }

      export function createTransitionResult<S extends string>(
        success: boolean,
        previousState: S,
        currentState: S,
        event: string,
        error?: string
      ): TransitionResult<S> {
        return { success, previousState, currentState, event, error };
      }

      export function createSuccessTransition<S extends string>(
        previousState: S,
        currentState: S,
        event: string
      ): TransitionResult<S> {
        return createTransitionResult(true, previousState, currentState, event);
      }

      export function createFailedTransition<S extends string>(
        currentState: S,
        event: string,
        error: string
      ): TransitionResult<S> {
        return createTransitionResult(false, currentState, currentState, event, error);
      }
    Criterio de Ã‰xito: "Tipos compilan"

  TAREA-04.10.3:
    Nombre: "Implementar task-machine.ts"
    AcciÃ³n: "MÃ¡quina de estados de tareas"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/state-machines/task-machine.ts:

      import { TransitionResult, StateMachineConfig, createSuccessTransition, createFailedTransition } from './types';

      export enum TaskState {
        PENDING = 'pending',
        IN_PROGRESS = 'in_progress',
        COMPLETED = 'completed',
        SKIPPED = 'skipped',
        FAILED = 'failed'
      }

      export enum TaskEvent {
        START = 'start',
        COMPLETE = 'complete',
        SKIP = 'skip',
        FAIL = 'fail',
        RESET = 'reset',
        CANCEL = 'cancel'
      }

      export const TASK_STATE_MACHINE: StateMachineConfig<TaskState, TaskEvent> = {
        initialState: TaskState.PENDING,
        states: {
          [TaskState.PENDING]: {
            on: {
              [TaskEvent.START]: TaskState.IN_PROGRESS,
              [TaskEvent.SKIP]: TaskState.SKIPPED,
              [TaskEvent.FAIL]: TaskState.FAILED
            }
          },
          [TaskState.IN_PROGRESS]: {
            on: {
              [TaskEvent.COMPLETE]: TaskState.COMPLETED,
              [TaskEvent.CANCEL]: TaskState.PENDING,
              [TaskEvent.FAIL]: TaskState.FAILED
            }
          },
          [TaskState.COMPLETED]: {
            isFinal: true,
            on: {
              [TaskEvent.RESET]: TaskState.PENDING
            }
          },
          [TaskState.SKIPPED]: {
            isFinal: true,
            on: {
              [TaskEvent.RESET]: TaskState.PENDING
            }
          },
          [TaskState.FAILED]: {
            isFinal: true,
            on: {
              [TaskEvent.RESET]: TaskState.PENDING
            }
          }
        }
      };

      export function canTransitionTask(
        currentState: TaskState,
        event: TaskEvent
      ): boolean {
        const stateConfig = TASK_STATE_MACHINE.states[currentState];
        return event in stateConfig.on;
      }

      export function transitionTask(
        currentState: TaskState,
        event: TaskEvent
      ): TransitionResult<TaskState> {
        if (!canTransitionTask(currentState, event)) {
          return createFailedTransition(
            currentState,
            event,
            `Cannot transition from "${currentState}" with event "${event}"`
          );
        }

        const nextState = TASK_STATE_MACHINE.states[currentState].on[event]!;
        return createSuccessTransition(currentState, nextState, event);
      }

      export function getValidTaskEvents(currentState: TaskState): TaskEvent[] {
        const stateConfig = TASK_STATE_MACHINE.states[currentState];
        return Object.keys(stateConfig.on) as TaskEvent[];
      }

      export function isTaskFinalState(state: TaskState): boolean {
        return TASK_STATE_MACHINE.states[state].isFinal === true;
      }
    Criterio de Ã‰xito: "MÃ¡quina de tareas funciona"

  TAREA-04.10.4:
    Nombre: "Implementar subscription-machine.ts"
    AcciÃ³n: "MÃ¡quina de estados de suscripciÃ³n"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/state-machines/subscription-machine.ts:

      import { TransitionResult, StateMachineConfig, createSuccessTransition, createFailedTransition } from './types';

      export enum SubscriptionState {
        TRIAL = 'trial',
        ACTIVE = 'active',
        PAST_DUE = 'past_due',
        LIMBO = 'limbo',
        CANCELLED = 'cancelled',
        EXPIRED = 'expired'
      }

      export enum SubscriptionEvent {
        SUBSCRIBE = 'subscribe',
        PAYMENT_SUCCESS = 'payment_success',
        PAYMENT_FAILED = 'payment_failed',
        CANCEL = 'cancel',
        REACTIVATE = 'reactivate',
        TRIAL_EXPIRED = 'trial_expired',
        GRACE_PERIOD_EXPIRED = 'grace_period_expired'
      }

      export const SUBSCRIPTION_STATE_MACHINE: StateMachineConfig<SubscriptionState, SubscriptionEvent> = {
        initialState: SubscriptionState.TRIAL,
        states: {
          [SubscriptionState.TRIAL]: {
            on: {
              [SubscriptionEvent.SUBSCRIBE]: SubscriptionState.ACTIVE,
              [SubscriptionEvent.TRIAL_EXPIRED]: SubscriptionState.EXPIRED
            }
          },
          [SubscriptionState.ACTIVE]: {
            on: {
              [SubscriptionEvent.PAYMENT_FAILED]: SubscriptionState.PAST_DUE,
              [SubscriptionEvent.CANCEL]: SubscriptionState.CANCELLED
            }
          },
          [SubscriptionState.PAST_DUE]: {
            on: {
              [SubscriptionEvent.PAYMENT_SUCCESS]: SubscriptionState.ACTIVE,
              [SubscriptionEvent.GRACE_PERIOD_EXPIRED]: SubscriptionState.LIMBO
            }
          },
          [SubscriptionState.LIMBO]: {
            on: {
              [SubscriptionEvent.PAYMENT_SUCCESS]: SubscriptionState.ACTIVE,
              [SubscriptionEvent.GRACE_PERIOD_EXPIRED]: SubscriptionState.EXPIRED
            }
          },
          [SubscriptionState.CANCELLED]: {
            on: {
              [SubscriptionEvent.REACTIVATE]: SubscriptionState.ACTIVE
            }
          },
          [SubscriptionState.EXPIRED]: {
            isFinal: false, // Puede reactivarse
            on: {
              [SubscriptionEvent.SUBSCRIBE]: SubscriptionState.ACTIVE
            }
          }
        }
      };

      export function canTransitionSubscription(
        currentState: SubscriptionState,
        event: SubscriptionEvent
      ): boolean {
        const stateConfig = SUBSCRIPTION_STATE_MACHINE.states[currentState];
        return event in stateConfig.on;
      }

      export function transitionSubscription(
        currentState: SubscriptionState,
        event: SubscriptionEvent
      ): TransitionResult<SubscriptionState> {
        if (!canTransitionSubscription(currentState, event)) {
          return createFailedTransition(
            currentState,
            event,
            `Cannot transition subscription from "${currentState}" with event "${event}"`
          );
        }

        const nextState = SUBSCRIPTION_STATE_MACHINE.states[currentState].on[event]!;
        return createSuccessTransition(currentState, nextState, event);
      }

      export function getValidSubscriptionEvents(
        currentState: SubscriptionState
      ): SubscriptionEvent[] {
        const stateConfig = SUBSCRIPTION_STATE_MACHINE.states[currentState];
        return Object.keys(stateConfig.on) as SubscriptionEvent[];
      }

      export function isSubscriptionActive(state: SubscriptionState): boolean {
        return state === SubscriptionState.ACTIVE || state === SubscriptionState.TRIAL;
      }

      export function isSubscriptionAtRisk(state: SubscriptionState): boolean {
        return state === SubscriptionState.PAST_DUE || state === SubscriptionState.LIMBO;
      }
    Criterio de Ã‰xito: "MÃ¡quina de suscripciÃ³n funciona"

  TAREA-04.10.5:
    Nombre: "Implementar image-machine.ts"
    AcciÃ³n: "MÃ¡quina de estados de generaciÃ³n de imagen"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/state-machines/image-machine.ts:

      import { TransitionResult, StateMachineConfig, createSuccessTransition, createFailedTransition } from './types';

      export enum ImageGenState {
        IDLE = 'idle',
        QUEUED = 'queued',
        GENERATING = 'generating',
        COMPLETED = 'completed',
        FAILED = 'failed'
      }

      export enum ImageGenEvent {
        REQUEST = 'request',
        PROCESS_START = 'process_start',
        PROCESS_COMPLETE = 'process_complete',
        PROCESS_FAIL = 'process_fail',
        RESET = 'reset'
      }

      export const IMAGE_GEN_STATE_MACHINE: StateMachineConfig<ImageGenState, ImageGenEvent> = {
        initialState: ImageGenState.IDLE,
        states: {
          [ImageGenState.IDLE]: {
            on: {
              [ImageGenEvent.REQUEST]: ImageGenState.QUEUED
            }
          },
          [ImageGenState.QUEUED]: {
            on: {
              [ImageGenEvent.PROCESS_START]: ImageGenState.GENERATING
            }
          },
          [ImageGenState.GENERATING]: {
            on: {
              [ImageGenEvent.PROCESS_COMPLETE]: ImageGenState.COMPLETED,
              [ImageGenEvent.PROCESS_FAIL]: ImageGenState.FAILED
            }
          },
          [ImageGenState.COMPLETED]: {
            on: {
              [ImageGenEvent.REQUEST]: ImageGenState.QUEUED,
              [ImageGenEvent.RESET]: ImageGenState.IDLE
            }
          },
          [ImageGenState.FAILED]: {
            on: {
              [ImageGenEvent.REQUEST]: ImageGenState.QUEUED,
              [ImageGenEvent.RESET]: ImageGenState.IDLE
            }
          }
        }
      };

      export function canTransitionImageGen(
        currentState: ImageGenState,
        event: ImageGenEvent
      ): boolean {
        const stateConfig = IMAGE_GEN_STATE_MACHINE.states[currentState];
        return event in stateConfig.on;
      }

      export function transitionImageGen(
        currentState: ImageGenState,
        event: ImageGenEvent
      ): TransitionResult<ImageGenState> {
        if (!canTransitionImageGen(currentState, event)) {
          return createFailedTransition(
            currentState,
            event,
            `Cannot transition image generation from "${currentState}" with event "${event}"`
          );
        }

        const nextState = IMAGE_GEN_STATE_MACHINE.states[currentState].on[event]!;
        return createSuccessTransition(currentState, nextState, event);
      }

      export function getValidImageGenEvents(
        currentState: ImageGenState
      ): ImageGenEvent[] {
        const stateConfig = IMAGE_GEN_STATE_MACHINE.states[currentState];
        return Object.keys(stateConfig.on) as ImageGenEvent[];
      }

      export function isImageGenInProgress(state: ImageGenState): boolean {
        return state === ImageGenState.QUEUED || state === ImageGenState.GENERATING;
      }

      export function canRequestNewImage(state: ImageGenState): boolean {
        return state === ImageGenState.IDLE ||
               state === ImageGenState.COMPLETED ||
               state === ImageGenState.FAILED;
      }
    Criterio de Ã‰xito: "MÃ¡quina de imagen funciona"

  TAREA-04.10.6:
    Nombre: "Implementar index.ts para state-machines"
    AcciÃ³n: "Exports pÃºblicos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/state-machines/index.ts:

      // Types
      export type { TransitionResult, StateDefinition, StateMachineConfig } from './types';
      export { createTransitionResult, createSuccessTransition, createFailedTransition } from './types';

      // Task Machine
      export { TaskState, TaskEvent, TASK_STATE_MACHINE } from './task-machine';
      export { canTransitionTask, transitionTask, getValidTaskEvents, isTaskFinalState } from './task-machine';

      // Subscription Machine
      export { SubscriptionState, SubscriptionEvent, SUBSCRIPTION_STATE_MACHINE } from './subscription-machine';
      export { canTransitionSubscription, transitionSubscription, getValidSubscriptionEvents, isSubscriptionActive, isSubscriptionAtRisk } from './subscription-machine';

      // Image Gen Machine
      export { ImageGenState, ImageGenEvent, IMAGE_GEN_STATE_MACHINE } from './image-machine';
      export { canTransitionImageGen, transitionImageGen, getValidImageGenEvents, isImageGenInProgress, canRequestNewImage } from './image-machine';
    Criterio de Ã‰xito: "Exports funcionan"

  TAREA-04.10.7:
    Nombre: "Implementar tests de state-machines"
    AcciÃ³n: "Suite completa de tests"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/state-machines/state-machines.test.ts:

      import { describe, it, expect } from 'vitest';
      import {
        TaskState, TaskEvent, transitionTask, canTransitionTask, getValidTaskEvents, isTaskFinalState,
        SubscriptionState, SubscriptionEvent, transitionSubscription, canTransitionSubscription,
        ImageGenState, ImageGenEvent, transitionImageGen, canTransitionImageGen
      } from './index';

      // ========================================
      // TASK STATE MACHINE TESTS
      // ========================================

      describe('Task State Machine', () => {
        describe('canTransitionTask', () => {
          it('allows START from PENDING', () => {
            expect(canTransitionTask(TaskState.PENDING, TaskEvent.START)).toBe(true);
          });

          it('allows COMPLETE from IN_PROGRESS', () => {
            expect(canTransitionTask(TaskState.IN_PROGRESS, TaskEvent.COMPLETE)).toBe(true);
          });

          it('allows SKIP from PENDING', () => {
            expect(canTransitionTask(TaskState.PENDING, TaskEvent.SKIP)).toBe(true);
          });

          it('disallows COMPLETE from PENDING', () => {
            expect(canTransitionTask(TaskState.PENDING, TaskEvent.COMPLETE)).toBe(false);
          });

          it('disallows START from COMPLETED', () => {
            expect(canTransitionTask(TaskState.COMPLETED, TaskEvent.START)).toBe(false);
          });
        });

        describe('transitionTask', () => {
          it('transitions PENDING â†’ IN_PROGRESS on START', () => {
            const result = transitionTask(TaskState.PENDING, TaskEvent.START);
            expect(result.success).toBe(true);
            expect(result.previousState).toBe(TaskState.PENDING);
            expect(result.currentState).toBe(TaskState.IN_PROGRESS);
          });

          it('transitions IN_PROGRESS â†’ COMPLETED on COMPLETE', () => {
            const result = transitionTask(TaskState.IN_PROGRESS, TaskEvent.COMPLETE);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(TaskState.COMPLETED);
          });

          it('fails for invalid transition', () => {
            const result = transitionTask(TaskState.PENDING, TaskEvent.COMPLETE);
            expect(result.success).toBe(false);
            expect(result.currentState).toBe(TaskState.PENDING);
            expect(result.error).toBeDefined();
          });

          it('allows RESET from terminal states', () => {
            const fromCompleted = transitionTask(TaskState.COMPLETED, TaskEvent.RESET);
            expect(fromCompleted.success).toBe(true);
            expect(fromCompleted.currentState).toBe(TaskState.PENDING);

            const fromSkipped = transitionTask(TaskState.SKIPPED, TaskEvent.RESET);
            expect(fromSkipped.success).toBe(true);

            const fromFailed = transitionTask(TaskState.FAILED, TaskEvent.RESET);
            expect(fromFailed.success).toBe(true);
          });
        });

        describe('getValidTaskEvents', () => {
          it('returns [START, SKIP, FAIL] for PENDING', () => {
            const events = getValidTaskEvents(TaskState.PENDING);
            expect(events).toContain(TaskEvent.START);
            expect(events).toContain(TaskEvent.SKIP);
            expect(events).toContain(TaskEvent.FAIL);
          });

          it('returns [RESET] for COMPLETED', () => {
            const events = getValidTaskEvents(TaskState.COMPLETED);
            expect(events).toEqual([TaskEvent.RESET]);
          });
        });

        describe('isTaskFinalState', () => {
          it('returns true for COMPLETED, SKIPPED, FAILED', () => {
            expect(isTaskFinalState(TaskState.COMPLETED)).toBe(true);
            expect(isTaskFinalState(TaskState.SKIPPED)).toBe(true);
            expect(isTaskFinalState(TaskState.FAILED)).toBe(true);
          });

          it('returns false for PENDING, IN_PROGRESS', () => {
            expect(isTaskFinalState(TaskState.PENDING)).toBe(false);
            expect(isTaskFinalState(TaskState.IN_PROGRESS)).toBe(false);
          });
        });
      });

      // ========================================
      // SUBSCRIPTION STATE MACHINE TESTS
      // ========================================

      describe('Subscription State Machine', () => {
        describe('transitionSubscription', () => {
          it('transitions TRIAL â†’ ACTIVE on SUBSCRIBE', () => {
            const result = transitionSubscription(SubscriptionState.TRIAL, SubscriptionEvent.SUBSCRIBE);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.ACTIVE);
          });

          it('transitions ACTIVE â†’ PAST_DUE on PAYMENT_FAILED', () => {
            const result = transitionSubscription(SubscriptionState.ACTIVE, SubscriptionEvent.PAYMENT_FAILED);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.PAST_DUE);
          });

          it('transitions PAST_DUE â†’ LIMBO on GRACE_PERIOD_EXPIRED', () => {
            const result = transitionSubscription(SubscriptionState.PAST_DUE, SubscriptionEvent.GRACE_PERIOD_EXPIRED);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.LIMBO);
          });

          it('allows recovery from LIMBO with payment', () => {
            const result = transitionSubscription(SubscriptionState.LIMBO, SubscriptionEvent.PAYMENT_SUCCESS);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.ACTIVE);
          });

          it('transitions LIMBO â†’ EXPIRED after grace period', () => {
            const result = transitionSubscription(SubscriptionState.LIMBO, SubscriptionEvent.GRACE_PERIOD_EXPIRED);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.EXPIRED);
          });

          it('allows reactivation from CANCELLED', () => {
            const result = transitionSubscription(SubscriptionState.CANCELLED, SubscriptionEvent.REACTIVATE);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.ACTIVE);
          });

          it('allows new subscription from EXPIRED', () => {
            const result = transitionSubscription(SubscriptionState.EXPIRED, SubscriptionEvent.SUBSCRIBE);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(SubscriptionState.ACTIVE);
          });
        });
      });

      // ========================================
      // IMAGE GEN STATE MACHINE TESTS
      // ========================================

      describe('Image Gen State Machine', () => {
        describe('happy path', () => {
          it('follows IDLE â†’ QUEUED â†’ GENERATING â†’ COMPLETED', () => {
            let state = ImageGenState.IDLE;

            const r1 = transitionImageGen(state, ImageGenEvent.REQUEST);
            expect(r1.success).toBe(true);
            state = r1.currentState;
            expect(state).toBe(ImageGenState.QUEUED);

            const r2 = transitionImageGen(state, ImageGenEvent.PROCESS_START);
            expect(r2.success).toBe(true);
            state = r2.currentState;
            expect(state).toBe(ImageGenState.GENERATING);

            const r3 = transitionImageGen(state, ImageGenEvent.PROCESS_COMPLETE);
            expect(r3.success).toBe(true);
            state = r3.currentState;
            expect(state).toBe(ImageGenState.COMPLETED);
          });
        });

        describe('failure path', () => {
          it('handles GENERATING â†’ FAILED', () => {
            const result = transitionImageGen(ImageGenState.GENERATING, ImageGenEvent.PROCESS_FAIL);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(ImageGenState.FAILED);
          });

          it('allows retry from FAILED', () => {
            const result = transitionImageGen(ImageGenState.FAILED, ImageGenEvent.REQUEST);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(ImageGenState.QUEUED);
          });
        });

        describe('new request from completed', () => {
          it('allows new request from COMPLETED', () => {
            const result = transitionImageGen(ImageGenState.COMPLETED, ImageGenEvent.REQUEST);
            expect(result.success).toBe(true);
            expect(result.currentState).toBe(ImageGenState.QUEUED);
          });
        });
      });
    Criterio de Ã‰xito: "Todos los tests pasan"

  TAREA-04.10.8:
    Nombre: "Ejecutar tests de state-machines"
    AcciÃ³n: "Verificar suite completa"
    Responsable: Antigravity
    Comando: |
      npm run test src/lib/core/state-machines/state-machines.test.ts
    Criterio de Ã‰xito: "100% tests pasan"

  ---
  TAREA FINAL DE CAJA 04

  TAREA-04.11.1:
    Nombre: "Crear index.ts raÃ­z del core"
    AcciÃ³n: "Re-exportar todos los mÃ³dulos"
    Responsable: Antigravity
    Prompt para Antigravity: |
      Crea /src/lib/core/index.ts que re-exporta todos los mÃ³dulos:

      // Vectors
      export * from './vectors';

      // Levels
      export * from './levels';

      // Health
      export * from './health';

      // Streak
      export * from './streak';

      // Judgement
      export * from './judgement';

      // Death
      export * from './death';

      // Economy
      export * from './economy';

      // Protocol
      export * from './protocol';

      // Validations
      export * from './validations';

      // State Machines
      export * from './state-machines';
    Criterio de Ã‰xito: "Import desde @/lib/core funciona"

  TAREA-04.11.2:
    Nombre: "Ejecutar suite completa de tests del core"
    AcciÃ³n: "Verificar que todo funciona"
    Responsable: Antigravity
    Comando: |
      npm run test src/lib/core/
    Criterio de Ã‰xito: "Todos los tests pasan, coverage > 85%"

  TAREA-04.11.3:
    Nombre: "Verificar exports y types"
    AcciÃ³n: "Comprobar que TypeScript no da errores"
    Responsable: Antigravity
    Comando: |
      npx tsc --noEmit
    Criterio de Ã‰xito: "Sin errores de TypeScript"

  ---
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘                                                                                      â•‘
  â•‘                    ğŸ“Š RESUMEN FINAL - CAJA 04                                        â•‘
  â•‘                                                                                      â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘                                                                                      â•‘
  â•‘  SUBCAJA 04.1: Sistema de Vectores           â”‚ 13 tareas  â”‚ ~800 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.2: Sistema de Niveles            â”‚  7 tareas  â”‚ ~500 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.3: Sistema de Salud              â”‚  7 tareas  â”‚ ~400 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.4: Sistema de Racha              â”‚  5 tareas  â”‚ ~350 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.5: Judgement Night               â”‚  7 tareas  â”‚ ~600 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.6: Muerte y ResurrecciÃ³n         â”‚  7 tareas  â”‚ ~350 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.7: EconomÃ­a                      â”‚  9 tareas  â”‚ ~450 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.8: Protocolo de 100 DÃ­as         â”‚  8 tareas  â”‚ ~650 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.9: Validaciones de Negocio       â”‚  8 tareas  â”‚ ~500 lÃ­neas             â•‘
  â•‘  SUBCAJA 04.10: MÃ¡quinas de Estado           â”‚  8 tareas  â”‚ ~550 lÃ­neas             â•‘
  â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•‘
  â•‘  SUBTOTAL SUBCAJAS                           â”‚ 79 tareas  â”‚ ~5,150 lÃ­neas           â•‘
  â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•‘
  â•‘  TAREAS FINALES (index + tests globales)     â”‚  3 tareas  â”‚                         â•‘
  â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•‘
  â•‘  TOTAL CAJA 04                               â”‚ 82 tareas  â”‚ ~5,150 lÃ­neas cÃ³digo    â•‘
  â•‘                                                                                      â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  ---
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘                         PROGRESO DE DESGLOSE ATÃ“MICO                                 â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘                                                                                      â•‘
  â•‘  ğŸ“¦ CAJA 01: DocumentaciÃ³n Fundacional    â”‚ 9 subcajas  â”‚  92 tareas â”‚ âœ… COMPLETO  â•‘
  â•‘  ğŸ“¦ CAJA 02: Infraestructura y DevOps     â”‚ 8 subcajas  â”‚  50 tareas â”‚ âœ… COMPLETO  â•‘
  â•‘  ğŸ“¦ CAJA 03: Base de Datos y Backend      â”‚ 8 subcajas  â”‚  63 tareas â”‚ âœ… COMPLETO  â•‘
  â•‘  ğŸ“¦ CAJA 04: Motor Core (LÃ³gica Pura)     â”‚ 10 subcajas â”‚  82 tareas â”‚ âœ… COMPLETO  â•‘
  â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
  â•‘  ğŸ“¦ CAJA 05: AutenticaciÃ³n y Onboarding   â”‚ 7 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 06: Dashboard y UI               â”‚ 9 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 07: Arsenal de Herramientas      â”‚ 10 subcajas â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 08: IA Generativa                â”‚ 8 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 09: EconomÃ­a y Tienda            â”‚ 7 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 10: MonetizaciÃ³n (Stripe)        â”‚ 8 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 11: Notificaciones y Realtime    â”‚ 6 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 12: Observabilidad y Calidad     â”‚ 7 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  ğŸ“¦ CAJA 13: Lanzamiento y Operaciones    â”‚ 7 subcajas  â”‚  ?? tareas â”‚ â³ PENDIENTE â•‘
  â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘
  â•‘  TOTAL DESGLOSADO HASTA AHORA             â”‚ 35 subcajas â”‚ 287 tareas â”‚ 4/13 CAJAS   â•‘
  â•‘                                                                                      â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		